<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ChemBot — Problem Solver</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="hero">
    <div class="wrap">
      <h1>ChemBot</h1>
      <p class="lead">Fast, free, on-device chemistry tools — balanced equations, VSEPR shapes, and simple drawings. No AI key required.</p>
    </div>
  </header>

  <main class="wrap">

    <!-- Periodic Table -->
    <section class="card">
      <div class="section-head">
        <h2>Periodic Table</h2>
        <div class="legend">
          <span class="chip alkali">Alkali</span>
          <span class="chip alkaline">Alkaline Earth</span>
          <span class="chip transition">Transition</span>
          <span class="chip post">Post-Transition</span>
          <span class="chip metalloid">Metalloid</span>
          <span class="chip nonmetal">Nonmetal</span>
          <span class="chip halogen">Halogen</span>
          <span class="chip noble">Noble Gas</span>
          <span class="chip lanth">Lanthanide</span>
          <span class="chip act">Actinide</span>
        </div>
      </div>

      <!-- Hover card -->
      <div class="pt-info" id="pt-info" hidden>
        <div class="pt-big" id="pt-big">
          <div class="num" id="pt-num">—</div>
          <div class="sym" id="pt-sym">—</div>
          <div class="name" id="pt-name">Hover an element</div>
        </div>
        <div class="pt-props">
          <div>Atomic Mass (u) — <b id="pt-mass">—</b></div>
          <div>Symbol — <b id="pt-sym2">—</b></div>
          <div>Chemical Group Block — <b id="pt-block">—</b></div>
        </div>
      </div>

      <!-- Real 18×7 grid + f-block rows -->
      <div id="ptable" class="ptable"></div>
      <div class="fblock-note">* Lanthanides and Actinides shown below</div>
    </section>

    <!-- Solvers -->
    <section class="grid solver-grid">
      <!-- Equation -->
      <div class="card solver">
        <h3>Equation Builder</h3>
        <p class="muted">Enter reactants (with optional products). Examples: <code>Zn + CuSO4</code>, <code>H2 + O2 → H2O</code></p>
        <div class="form">
          <input id="eq-react" type="text" placeholder="e.g., H2 + O2 -> H2O">
          <button id="eq-run" class="primary">Balance</button>
        </div>
        <pre id="eq-out" class="result"></pre>
      </div>

      <!-- VSEPR -->
      <div class="card solver">
        <h3>VSEPR Shape</h3>
        <p class="muted">Give a formula or keyword. Examples: <code>NH3</code>, <code>CO2</code>, <code>C (graphite)</code></p>
        <div class="form">
          <input id="vs-input" type="text" placeholder="e.g., NH3">
          <button id="vs-run" class="primary">Analyze</button>
        </div>
        <div id="vs-svg" class="svgwrap"></div>
        <pre id="vs-out" class="result"></pre>
      </div>

      <!-- Drawings -->
      <div class="card solver">
        <h3>Element Drawings</h3>
        <p class="muted">Simple Bohr / Bohr-Rutherford / Lewis diagrams (first 20 elements supported for now).</p>
        <div class="form">
          <select id="draw-symbol"></select>
          <button id="draw-run" class="primary">Draw</button>
        </div>
        <div class="draw-grid">
          <div><h4>Bohr</h4><div id="svg-bohr" class="svgwrap"></div></div>
          <div><h4>Bohr-Rutherford</h4><div id="svg-br" class="svgwrap"></div></div>
          <div><h4>Lewis</h4><div id="svg-lewis" class="svgwrap"></div></div>
        </div>
        <p id="draw-notes" class="muted" style="margin-top:.6rem;"></p>
      </div>
    </section>

  </main>

  <!-- ===== Local data & solvers (one time) ===== -->
<script>
  // Atomic number + VALENCE ELECTRONS (VE) for first 20
  window.PERIODIC = {
    Z:{H:1,He:2,Li:3,Be:4,B:5,C:6,N:7,O:8,F:9,Ne:10,Na:11,Mg:12,Al:13,Si:14,P:15,S:16,Cl:17,Ar:18,K:19,Ca:20},
    VE:{H:1,He:2,Li:1,Be:2,B:3,C:4,N:5,O:6,F:7,Ne:8,Na:1,Mg:2,Al:3,Si:4,P:5,S:6,Cl:7,Ar:8,K:1,Ca:2}
  };
</script>
<script>
(()=>{ // LocalChem v2 — products, ΔH°rxn via ΔH°f, mechanisms

  /* ========== Utilities ========== */
  function parseFormula(f){const s=[{}];const r=/([A-Z][a-z]?|\(|\)|\d+)/g;let m;
    while((m=r.exec(f))){const t=m[1];
      if(t==='('){s.push({});continue}
      if(t===')'){const top=s.pop();const mult=/^\d+/.exec(f.slice(r.lastIndex))?.[0];const k=mult?parseInt(mult,10):1;if(mult)r.lastIndex+=mult.length;for(const e in top)s[s.length-1][e]=(s[s.length-1][e]||0)+top[e]*k;continue}
      if(/^\d+$/.test(t))continue;const el=t;const mult=/^\d+/.exec(f.slice(r.lastIndex))?.[0];const k=mult?parseInt(mult,10):1;if(mult)r.lastIndex+=mult.length;s[s.length-1][el]=(s[s.length-1][el]||0)+k
    }return s[0]}
  function parseSide(side){return side.split('+').map(x=>{const t=x.trim();const m=/^\s*(\d+)\s+(.+)$/.exec(t);return m?{coef:parseInt(m[1],10),formula:m[2].trim()}:{coef:1,formula:t}})}
  function buildMatrix(lhs,rhs){const sp=[...lhs,...rhs],els=new Set();sp.forEach(p=>{p.comp=parseFormula(p.formula);Object.keys(p.comp).forEach(k=>els.add(k))});
    const e=[...els],C=sp.length,R=e.length,A=[...Array(R)].map(()=>Array(C).fill(0));
    e.forEach((el,i)=>{lhs.forEach((p,j)=>A[i][j]=p.comp[el]||0);rhs.forEach((p,j)=>A[i][j+lhs.length]=-(p.comp[el]||0))});
    return {A,lhs,rhs}}
  function balanceEquation(input){
    const [L,R]=input.split('->').map(s=>s.trim()); if(!L||!R) throw new Error("Use 'reactants -> products'");
    const lhs=parseSide(L), rhs=parseSide(R), {A}=buildMatrix(lhs,rhs);
    const rows=A.length+1, cols=A[0].length, M=[...Array(rows)].map(()=>Array(cols).fill(0));
    for(let i=0;i<A.length;i++)for(let j=0;j<cols;j++)M[i][j]=A[i][j];
    M[rows-1][cols-1]=1; const b=Array(rows).fill(0); b[rows-1]=1;
    const aug=M.map((row,i)=>row.concat([b[i]]));
    const gcd=(a,b)=>b?gcd(b,a%b):Math.abs(a); const lcm=(a,b)=>Math.abs(a*b)/gcd(a,b);
    for(let col=0,row=0;col<cols&&row<rows;col++){
      let piv=row; while(piv<rows&&aug[piv][col]===0)piv++; if(piv===rows)continue;
      [aug[row],aug[piv]]=[aug[piv],aug[row]]; const pv=aug[row][col];
      for(let c=col;c<=cols;c++)aug[row][c]/=pv;
      for(let r=0;r<rows;r++){ if(r===row)continue; const f=aug[r][col]; if(f!==0) for(let c=col;c<=cols;c++)aug[r][c]-=f*aug[row][c]; }
      row++;
    }
    const x=aug.slice(0,cols).map(r=>r[cols]||0);
    const den=x.map(v=>{const s=v.toString();return s.includes('.')?10**s.split('.')[1].length:1});
    const LCM=den.reduce((p,c)=>lcm(p,c),1); let nums=x.map(v=>Math.round(v*LCM));
    const G=nums.reduce((p,c)=>gcd(p,c),nums[0]||1); nums=nums.map(v=>Math.abs(v/G));
    const left=lhs.map((p,i)=>({coef:nums[i], formula:p.formula}));
    const right=rhs.map((p,i)=>({coef:nums[i+lhs.length], formula:p.formula}));
    const lstr=left.map(p=>`${p.coef===1?'':p.coef+' '}${p.formula}`).join(' + ');
    const rstr=right.map(p=>`${p.coef===1?'':p.coef+' '}${p.formula}`).join(' + ');
    return {balanced:`${lstr} -> ${rstr}`, left, right};
  }

  /* ========== ΔH°f database (kJ/mol at 298 K) — extendable ========== */
  const Hf = {
    "H2(g)":0, "O2(g)":0, "N2(g)":0, "Cl2(g)":0, "HCl(aq)":-167.2,
    "H2O(l)":-285.8, "H2O(g)":-241.8, "CO2(g)":-393.5, "CO(g)":-110.5,
    "CH4(g)":-74.8, "C2H6(g)":-84.0, "C2H4(g)":52.3, "C2H2(g)":226.7,
    "NaOH(aq)":-469.6, "NaCl(s)":-411.2, "NaCl(aq)":-407.3,
    "CuSO4(aq)":-769.9, "ZnSO4(aq)":-980.0, "Cu(s)":0, "Zn(s)":0,
    "CaCO3(s)":-1206.9, "CaO(s)":-635.1, "SO2(g)":-296.8, "SO3(g)":-395.7,
    "NH3(g)":-46.1, "NO2(g)":33.2, "H2SO4(aq)":-909.3
  };
  function HfLookup(species){
    // try exact, then assume (g), then (aq), then (s)
    if(Hf[species]!==undefined) return Hf[species];
    const base = species.replace(/\s+/g,'');
    for(const phase of ["(g)","(aq)","(l)","(s)"]){
      const k = `${base}${phase}`; if(Hf[k]!==undefined) return Hf[k];
    }
    return null;
  }
  function deltaH_from_Hf(left,right){
    // ΔH°rxn = Σν Hf(products) − Σν Hf(reactants)
    let prod=0, react=0;
    for(const p of right){
      const v=HfLookup(p.formula); if(v===null) return {dH:null, note:"ΔH°f unavailable for at least one product."};
      prod += v * p.coef;
    }
    for(const r of left){
      const v=HfLookup(r.formula); if(v===null) return {dH:null, note:"ΔH°f unavailable for at least one reactant."};
      react += v * r.coef;
    }
    return {dH: Math.round((prod-react)*10)/10, note:"Calculated from tabulated ΔH°f (kJ/mol)."};
  }

  /* ========== Product prediction (simple but useful) ========== */
  const METALS = new Set(["Li","Na","K","Rb","Cs","Mg","Ca","Sr","Ba","Al","Zn","Fe","Cu","Ag","Au","Ni","Co","Sn","Pb"]);
  const COMMON_ANIONS = ["Cl","Br","I","NO3","SO4","CO3","OH","PO4","F","CN"];

  function isO2(x){return x.replace(/\s+/g,'').toUpperCase()==="O2";}
  function hydrocarbonLike(x){
    const m=/^C(\d*)(H\d+)(O\d+)?$/i.exec(x.replace(/\s+/g,''));
    if(!m) return null;
    const C=parseInt(m[1]||"1",10), hasO=!!m[3];
    return {C, hasO};
  }
  function isAcid(x){ return /^H[A-Z]/.test(x) && !/^H2O$/.test(x); }
  function isHydroxide(x){ return /OH/.test(x) && !/^H2O$/.test(x); }
  function isMetalElement(x){ return METALS.has(x.replace(/\s+/g,'')); }
  function splitSalt(x){
    // very naive: metal first token, remainder is anion (strip count)
    const m=/^([A-Z][a-z]?)(.*)$/.exec(x.replace(/\s+/g,''));
    if(!m) return null;
    const cation=m[1], rest=m[2] || "";
    const anion = COMMON_ANIONS.find(a=>rest.startsWith(a));
    return anion ? {cation, anion} : null;
  }

function predictProducts(reactants){
  const R = reactants.map(s=>s.trim());

  // 0) Special: water formation
  if(R.includes("H2") && R.includes("O2")){
    return {type:"synthesis (oxidation)", products:["H2O(l)"], mechanism:[
      "Initiation of O2 to reactive species (overall model)",
      "H–H broken, O–H formed",
      "Overall: 2 H2 + O2 → 2 H2O"
    ]};
  }

  // 1) Combustion of hydrocarbons/alcohols: → CO2 + H2O
  const hasO2 = R.some(x=>x.replace(/\s+/g,'').toUpperCase()==="O2");
  const hc = R.find(x=>/^C\d*H\d+([O]\d+)?$/i.test(x.replace(/\s+/g,'')));
  if(hasO2 && hc){
    return {type:"combustion", products:["CO2(g)","H2O(l)"], mechanism:[
      "Oxidation of C/H framework",
      "C=O and O–H bond formation dominates enthalpy"
    ]};
  }

  // 2) Simple element oxidation: C + O2 → CO2 ; S + O2 → SO2
  if(hasO2 && R.includes("C"))  return {type:"oxidation", products:["CO2(g)"], mechanism:["Carbon oxidized to CO2"]};
  if(hasO2 && R.includes("S"))  return {type:"oxidation", products:["SO2(g)"], mechanism:["Sulfur oxidized to SO2"]};

  // 3) Acid–base: HA + MOH → MA + H2O
  const isAcid = x => /^H[A-Z]/.test(x) && !/^H2O$/.test(x);
  const isBase = x => /(OH)/.test(x) && !/^H2O$/.test(x);
  if(R.some(isAcid) && R.some(isBase)){
    const acid = R.find(isAcid), base = R.find(isBase);
    const acidAnion = acid.replace(/^H/,'');
    const baseCat = (/^([A-Z][a-z]?)/.exec(base)||[])[1] || "Na";
    return {type:"acid-base", products:[`${baseCat}${acidAnion}(aq)`,"H2O(l)"], mechanism:[
      "HA → H⁺ + A⁻", "MOH → M⁺ + OH⁻", "H⁺ + OH⁻ → H2O", "M⁺ + A⁻ → MA"
    ]};
  }

  // 4) Single replacement: M + M'X → M' + MX
  const METALS = new Set(["Li","Na","K","Rb","Cs","Mg","Ca","Sr","Ba","Al","Zn","Fe","Cu","Ag","Ni","Co","Sn","Pb"]);
  const isMetal = x => METALS.has(x);
  const splitSalt = x => {
    const t=x.replace(/\s+/g,''); const m=/^([A-Z][a-z]?)(.*)$/.exec(t); if(!m) return null;
    const c=m[1], rest=m[2]||""; const AN=["Cl","Br","I","NO3","SO4","CO3","OH","PO4","F","CN"];
    const a = AN.find(a=>rest.startsWith(a)); return a?{cation:c, anion:a}:null;
  };
  const metal = R.find(isMetal), salt = R.map(splitSalt).find(Boolean);
  if(metal && salt){
    return {type:"single replacement (redox)", products:[`${metal}${salt.anion}(aq)`, `${salt.cation}(s)`], mechanism:[
      `${metal} → ${metal}ⁿ⁺ + n e⁻`,
      `${salt.cation}ᵐ⁺ + m e⁻ → ${salt.cation}(s)`
    ]};
  }

  // 5) Double displacement: AB + CD → AD + CB
  const salts = R.map(splitSalt).filter(Boolean);
  if(salts.length===2){
    const [s1,s2]=salts;
    return {type:"double displacement", products:[`${s1.cation}${s2.anion}(aq)`, `${s2.cation}${s1.anion}(aq)`], mechanism:[
      "Dissociation in water", "Ion exchange", "Check precipitation/neutralization"
    ]};
  }

  // 6) Very simple synthesis: A + B → AB (elements)
  if(R.length===2 && R.every(x=>/^[A-Z][a-z]?$/.test(x))){
    return {type:"synthesis", products:[`${R[0]}${R[1]}(s)`], mechanism:["Combination of elements"]};
  }

  return {type:"unknown", products:[], mechanism:[]};
}

  /* ========== Drawings (same as you have, white electrons) ========== */
  function shells(z){const s=[];let left=z;const cap=[2,8,8,18];for(let i=0;i<cap.length&&left>0;i++){const take=Math.min(cap[i],left);s.push(take);left-=take}return s}
  function bohrSVG(symbol,z){
    const sh=shells(z);
    const dots = sh.map((n,i)=>{
      const R=40+30*i;
      return Array.from({length:n}).map((_,k)=>{
        const a=(k/n)*2*Math.PI, x=200+R*Math.cos(a), y=150+R*Math.sin(a);
        return `<circle cx="${x.toFixed(1)}" cy="${y.toFixed(1)}" r="3" fill="#fff"/>`;
      }).join('');
    }).join('');
    return `<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
      <circle cx="200" cy="150" r="8" fill="#fff"/>
      ${sh.map((_,i)=>`<circle cx="200" cy="150" r="${40+30*i}" stroke="#fff" stroke-width="2" fill="none"/>`).join('')}
      ${dots}
    </svg>`;
  }
  function lewisSVG(symbol,v){
    const pts = Array.from({length:v}).map((_,i)=>{
      const a=(i/v)*2*Math.PI, R=70, x=200+R*Math.cos(a), y=150+R*Math.sin(a);
      return `<circle cx="${x.toFixed(1)}" cy="${y.toFixed(1)}" r="5" fill="#fff"/>`;
    }).join('');
    return `<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
      <text x="200" y="160" text-anchor="middle" font-family="Inter,system-ui,sans-serif" font-size="64" fill="#fff">${symbol}</text>
      ${pts}
    </svg>`;
  }
  async function localDrawElement(symbol){
    const Z=PERIODIC.Z[symbol]; if(!Z) return {error:"Unknown element"};
    const sh=shells(Z); const v=(PERIODIC.VE?.[symbol] ?? (sh.at(-1)||0));
    return { valence_electrons:v, bohr:bohrSVG(symbol,Z), bohr_rutherford:bohrSVG(symbol,Z), lewis:lewisSVG(symbol,v), notes:"Bohr models with electrons; first 20 elements best supported." };
  }

  /* ---------- VSEPR (fixed: uses valence ELECTRONS) ---------- */
  const EG = {2:"linear",3:"trigonal planar",4:"tetrahedral",5:"trigonal bipyramidal",6:"octahedral"};

  function countBonds(formula){
  // tokens like ["H2","O"]
  const toks = (formula.replace(/\s+/g,'').match(/[A-Z][a-z]?\d*/g) || []);
  if (toks.length === 0) return { central: "X", bonds: 0 };

  // choose first NON-hydrogen token if possible (common general rule)
  let firstEl = null;
  for (const t of toks) {
    const el = /^[A-Z][a-z]?/.exec(t)[0];
    if (el !== "H") { firstEl = el; break; }
  }
  const central = firstEl || /^[A-Z][a-z]?/.exec(toks[0])[0];

  // count atoms of each element
  const counts = {};
  for (const tok of toks) {
    const el = /^[A-Z][a-z]?/.exec(tok)[0];
    const n = parseInt(tok.slice(el.length) || "1", 10);
    counts[el] = (counts[el] || 0) + n;
  }
  // crude bond count = total atoms not equal to the central element
  const bonds = Object.entries(counts).reduce((a,[el,n]) => el === central ? a : a + n, 0);
  return { central, bonds };
}

  function lonePairs(central, bonds){
    const VE = (window.PERIODIC.VE?.[central] ?? 4);           // valence electrons of central atom
    const lp = Math.max(0, Math.floor((VE - bonds)/2));        // lone pairs (integer)
    return lp;
  }

  function classifyGeometry(bonds, lp){
    const ed = bonds + lp;                    // electron domains
    const eg = EG[ed] || "unknown";          // electron geometry
    let mg = eg;                              // molecular geometry (default = eg)
    if(ed===3 && lp===1) mg="bent";
    if(ed===4 && lp===1) mg="trigonal pyramidal";
    if(ed===4 && lp===2) mg="bent";
    if(ed===5 && lp===1) mg="seesaw";
    if(ed===5 && lp===2) mg="T-shaped";
    if(ed===5 && lp===3) mg="linear";
    if(ed===6 && lp===1) mg="square pyramidal";
    if(ed===6 && lp===2) mg="square planar";
    return {eg, mg, ed};
  }

  function drawVSEPR(mg){
    const C="stroke='#fff' stroke-width='2' fill='none'", F="fill='#fff'";
    const center=`<circle ${F} cx="200" cy="150" r="6"/>`;
    const L=(pts)=>pts.map(([x,y])=>`<line ${C} x1="200" y1="150" x2="${x}" y2="${y}"/>`).join('');
    const B=(pts)=>pts.map(([x,y])=>`<circle ${F} cx="${x}" cy="${y}" r="6"/>`).join('');
    let pts=[];
    switch(mg){
      case "linear": pts=[[110,150],[290,150]]; break;
      case "trigonal planar": pts=[[200,70],[140,210],[260,210]]; break;
      case "bent": pts=[[150,200],[250,200]]; break;
      case "tetrahedral": pts=[[200,70],[110,200],[290,200],[200,230]]; break;
      case "trigonal pyramidal": pts=[[200,70],[130,210],[270,210]]; break;
      case "seesaw": pts=[[110,150],[290,150],[200,70],[200,230]]; break;
      case "T-shaped": pts=[[110,150],[290,150],[200,70]]; break;
      case "square planar": pts=[[140,110],[260,110],[140,190],[260,190]]; break;
      case "square pyramidal": pts=[[200,70],[140,110],[260,110],[140,190],[260,190]]; break;
      case "octahedral": pts=[[200,60],[200,240],[120,150],[280,150],[140,110],[260,190]]; break;
      default: pts=[[200,70],[140,210],[260,210]];
    }
    return `<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">${center}${L(pts)}${B(pts)}</svg>`;
  }

  async function localSolveVSEPR(input){
    const f=input.trim().replace(/granite/ig,'graphite');
    const {central,bonds} = countBonds(f);
    const lp = lonePairs(central, bonds);
    const {eg, mg, ed} = classifyGeometry(bonds, lp);
    const svg = drawVSEPR(mg);
    return {
      system:"molecule",
      formula:f,
      electron_geometry: eg,
      molecular_geometry: mg,
      electron_domains: `${ed} (${bonds} bonding + ${lp} lone)`,
      bond_angles_deg: eg==="tetrahedral"?"~109.5°":eg==="trigonal planar"?"~120°":eg==="linear"?"180°":eg==="octahedral"?"90°":"varies",
      hybridization: eg==="linear"?"sp":eg==="trigonal planar"?"sp2":eg==="tetrahedral"?"sp3":eg==="trigonal bipyramidal"?"sp3d":eg==="octahedral"?"sp3d2":"—",
      svg
    };
  }

  /* ========== public API ========== */
  async function localSolveEquation(userInput){
  // normalize a few common “space before subscript” typos for polyatomics
  const norm = userInput
    .replace(/SO4\s*([2-9])/gi, '(SO4)$1')
    .replace(/NO3\s*([2-9])/gi, '(NO3)$1')
    .replace(/CO3\s*([2-9])/gi, '(CO3)$1')
    .replace(/PO4\s*([2-9])/gi, '(PO4)$1');

  // If user typed an arrow but no products, we still predict.
  if (norm.includes('->')) {
    const [L,R] = norm.split('->').map(s=>s.trim());
    if (!L) return { error: "Provide reactants before '->'." };
    if (!R) {
      const reactants = L.split('+').map(s=>s.trim()).filter(Boolean);
      const pred = predictProducts(reactants);
      if (!pred.products.length) return { error: "Couldn't predict products for those reactants." };
      const res = balanceEquation(`${reactants.join(' + ')} -> ${pred.products.join(' + ')}`);
      const dH = deltaH_from_Hf(res.left,res.right);
      return {
        balanced_equation: res.balanced,
        products: res.right.map(p=>p.formula),
        reaction_type: pred.type,
        enthalpy_kJ_per_mol: dH.dH,
        notes: dH.note,
        mechanism: pred.mechanism
      };
    }
    // Arrow with explicit products: just balance + ΔH°
    const res = balanceEquation(norm);
    const dH = deltaH_from_Hf(res.left,res.right);
    return {
      balanced_equation: res.balanced,
      products: res.right.map(p=>p.formula),
      reaction_type: "user-specified",
      enthalpy_kJ_per_mol: dH.dH,
      notes: dH.note,
      mechanism: []
    };
  }

  // No arrow: predict products then balance.
  const reactants = norm.split('+').map(s=>s.trim()).filter(Boolean);
  const pred = predictProducts(reactants);
  if (!pred.products.length) return { error: "Couldn't predict products for that input. Add products (A + B -> ...) or use a simpler pair." };
  const res = balanceEquation(`${reactants.join(' + ')} -> ${pred.products.join(' + ')}`);
  const dH = deltaH_from_Hf(res.left,res.right);
  return {
    balanced_equation: res.balanced,
    products: res.right.map(p=>p.formula),
    reaction_type: pred.type,
    enthalpy_kJ_per_mol: dH.dH,
    notes: dH.note,
    mechanism: pred.mechanism
  };
}

  window.LocalChem = { localSolveEquation, localDrawElement, localSolveVSEPR };
})();
</script>

  <!-- Table renderer -->
  <script>
  (()=>{
    const grid = document.getElementById('ptable');
    if(!grid) return;

    // 18×7 main grid with explicit gaps, then row8/9 for f-block
    grid.style.setProperty('--cols', 18);

    // dataset: [Z, sym, name, mass, col, row, block]
    const main = [
      [1,"H","Hydrogen",1.008,1,1,"Nonmetal"],
      [2,"He","Helium",4.0026,18,1,"Noble Gas"],
      [3,"Li","Lithium",6.94,1,2,"Alkali Metal"],[4,"Be","Beryllium",9.0122,2,2,"Alkaline Earth Metal"],
      [5,"B","Boron",10.81,13,2,"Metalloid"],[6,"C","Carbon",12.011,14,2,"Nonmetal"],[7,"N","Nitrogen",14.007,15,2,"Nonmetal"],[8,"O","Oxygen",15.999,16,2,"Nonmetal"],[9,"F","Fluorine",18.998,17,2,"Halogen"],[10,"Ne","Neon",20.18,18,2,"Noble Gas"],
      [11,"Na","Sodium",22.99,1,3,"Alkali Metal"],[12,"Mg","Magnesium",24.305,2,3,"Alkaline Earth Metal"],
      [13,"Al","Aluminum",26.982,13,3,"Post-Transition Metal"],[14,"Si","Silicon",28.085,14,3,"Metalloid"],[15,"P","Phosphorus",30.974,15,3,"Nonmetal"],[16,"S","Sulfur",32.06,16,3,"Nonmetal"],[17,"Cl","Chlorine",35.45,17,3,"Halogen"],[18,"Ar","Argon",39.95,18,3,"Noble Gas"],
      [19,"K","Potassium",39.098,1,4,"Alkali Metal"],[20,"Ca","Calcium",40.078,2,4,"Alkaline Earth Metal"],
      [21,"Sc","Scandium",44.956,3,4,"Transition Metal"],[22,"Ti","Titanium",47.867,4,4,"Transition Metal"],[23,"V","Vanadium",50.942,5,4,"Transition Metal"],[24,"Cr","Chromium",51.996,6,4,"Transition Metal"],[25,"Mn","Manganese",54.938,7,4,"Transition Metal"],[26,"Fe","Iron",55.845,8,4,"Transition Metal"],[27,"Co","Cobalt",58.933,9,4,"Transition Metal"],[28,"Ni","Nickel",58.693,10,4,"Transition Metal"],[29,"Cu","Copper",63.546,11,4,"Transition Metal"],[30,"Zn","Zinc",65.38,12,4,"Transition Metal"],
      [31,"Ga","Gallium",69.723,13,4,"Post-Transition Metal"],[32,"Ge","Germanium",72.63,14,4,"Metalloid"],[33,"As","Arsenic",74.922,15,4,"Metalloid"],[34,"Se","Selenium",78.971,16,4,"Nonmetal"],[35,"Br","Bromine",79.904,17,4,"Halogen"],[36,"Kr","Krypton",83.798,18,4,"Noble Gas"],
      [37,"Rb","Rubidium",85.468,1,5,"Alkali Metal"],[38,"Sr","Strontium",87.62,2,5,"Alkaline Earth Metal"],
      [39,"Y","Yttrium",88.906,3,5,"Transition Metal"],[40,"Zr","Zirconium",91.224,4,5,"Transition Metal"],[41,"Nb","Niobium",92.906,5,5,"Transition Metal"],[42,"Mo","Molybdenum",95.95,6,5,"Transition Metal"],[43,"Tc","Technetium",98,7,5,"Transition Metal"],[44,"Ru","Ruthenium",101.07,8,5,"Transition Metal"],[45,"Rh","Rhodium",102.906,9,5,"Transition Metal"],[46,"Pd","Palladium",106.42,10,5,"Transition Metal"],[47,"Ag","Silver",107.868,11,5,"Transition Metal"],[48,"Cd","Cadmium",112.414,12,5,"Transition Metal"],[49,"In","Indium",114.818,13,5,"Post-Transition Metal"],[50,"Sn","Tin",118.71,14,5,"Post-Transition Metal"],[51,"Sb","Antimony",121.76,15,5,"Metalloid"],[52,"Te","Tellurium",127.6,16,5,"Metalloid"],[53,"I","Iodine",126.904,17,5,"Halogen"],[54,"Xe","Xenon",131.293,18,5,"Noble Gas"],
      [55,"Cs","Cesium",132.905,1,6,"Alkali Metal"],[56,"Ba","Barium",137.33,2,6,"Alkaline Earth Metal"],
      [72,"Hf","Hafnium",178.49,4,6,"Transition Metal"],[73,"Ta","Tantalum",180.947,5,6,"Transition Metal"],[74,"W","Tungsten",183.84,6,6,"Transition Metal"],[75,"Re","Rhenium",186.207,7,6,"Transition Metal"],[76,"Os","Osmium",190.23,8,6,"Transition Metal"],[77,"Ir","Iridium",192.217,9,6,"Transition Metal"],[78,"Pt","Platinum",195.08,10,6,"Transition Metal"],[79,"Au","Gold",196.967,11,6,"Transition Metal"],[80,"Hg","Mercury",200.59,12,6,"Transition Metal"],[81,"Tl","Thallium",204.38,13,6,"Post-Transition Metal"],[82,"Pb","Lead",207.2,14,6,"Post-Transition Metal"],[83,"Bi","Bismuth",208.98,15,6,"Post-Transition Metal"],[84,"Po","Polonium",209,16,6,"Metalloid"],[85,"At","Astatine",210,17,6,"Halogen"],[86,"Rn","Radon",222,18,6,"Noble Gas"],
      [87,"Fr","Francium",223,1,7,"Alkali Metal"],[88,"Ra","Radium",226,2,7,"Alkaline Earth Metal"],
      [104,"Rf","Rutherfordium",267,4,7,"Transition Metal"],[105,"Db","Dubnium",268,5,7,"Transition Metal"],[106,"Sg","Seaborgium",269,6,7,"Transition Metal"],[107,"Bh","Bohrium",270,7,7,"Transition Metal"],[108,"Hs","Hassium",269,8,7,"Transition Metal"],[109,"Mt","Meitnerium",278,9,7,"Transition Metal"],[110,"Ds","Darmstadtium",281,10,7,"Transition Metal"],[111,"Rg","Roentgenium",282,11,7,"Transition Metal"],[112,"Cn","Copernicium",285,12,7,"Transition Metal"],[113,"Nh","Nihonium",286,13,7,"Post-Transition Metal"],[114,"Fl","Flerovium",289,14,7,"Post-Transition Metal"],[115,"Mc","Moscovium",290,15,7,"Post-Transition Metal"],[116,"Lv","Livermorium",293,16,7,"Post-Transition Metal"],[117,"Ts","Tennessine",294,17,7,"Halogen"],[118,"Og","Oganesson",295,18,7,"Noble Gas"]
    ];
    const lan = [[57,"La","Lanthanum"],[58,"Ce","Cerium"],[59,"Pr","Praseodymium"],[60,"Nd","Neodymium"],[61,"Pm","Promethium"],[62,"Sm","Samarium"],[63,"Eu","Europium"],[64,"Gd","Gadolinium"],[65,"Tb","Terbium"],[66,"Dy","Dysprosium"],[67,"Ho","Holmium"],[68,"Er","Erbium"],[69,"Tm","Thulium"],[70,"Yb","Ytterbium"],[71,"Lu","Lutetium"]];
    const act = [[89,"Ac","Actinium"],[90,"Th","Thorium"],[91,"Pa","Protactinium"],[92,"U","Uranium"],[93,"Np","Neptunium"],[94,"Pu","Plutonium"],[95,"Am","Americium"],[96,"Cm","Curium"],[97,"Bk","Berkelium"],[98,"Cf","Californium"],[99,"Es","Einsteinium"],[100,"Fm","Fermium"],[101,"Md","Mendelevium"],[102,"No","Nobelium"],[103,"Lr","Lawrencium"]];

    const blockClass = b=>{
      const k = b.toLowerCase();
      if(k.includes('alkali') && !k.includes('earth')) return 'pt-alkali';
      if(k.includes('alkaline')||k.includes('earth')) return 'pt-alkaline';
      if(k.includes('transition')) return 'pt-transition';
      if(k.includes('post')) return 'pt-post';
      if(k.includes('metalloid')) return 'pt-metalloid';
      if(k.includes('nonmetal')) return 'pt-nonmetal';
      if(k.includes('halogen')) return 'pt-halogen';
      if(k.includes('noble')) return 'pt-noble';
      if(k.includes('lanthan')) return 'pt-lanth';
      if(k.includes('actin')) return 'pt-act';
      return '';
    };

    // Render helper
    const makeTile = (Z,sym,name,mass,col,row,block)=>{
      const d = document.createElement('div');
      d.className = `elem ${blockClass(block)}`;
      d.style.gridColumn = col;
      d.style.gridRow = row;
      d.innerHTML = `
        <div class="num">${Z}</div>
        <div class="sym">${sym}</div>
        <div class="name">${name}</div>
        <div class="mass">${typeof mass==='number'?mass:''}</div>
      `;
      d.dataset.block=block; d.dataset.z=Z; d.dataset.sym=sym; d.dataset.name=name; d.dataset.mass = (mass??'—');
      return d;
    };

    // Draw main
    grid.innerHTML = '';
    main.forEach(e=>grid.appendChild(makeTile(...e)));

    // f-block rows 8 & 9
    lan.forEach((x,i)=>grid.appendChild(makeTile(x[0],x[1],x[2],undefined,3+i,8,'Lanthanide')));
    act.forEach((x,i)=>grid.appendChild(makeTile(x[0],x[1],x[2],undefined,3+i,9,'Actinide')));

    // Hover card
    const info = document.getElementById('pt-info');
    const setInfo = (t)=>{
      info.hidden = false;
      info.querySelector('#pt-num').textContent = t.dataset.z;
      info.querySelector('#pt-sym').textContent = t.dataset.sym;
      info.querySelector('#pt-name').textContent = t.dataset.name;
      info.querySelector('#pt-sym2').textContent = t.dataset.sym;
      info.querySelector('#pt-mass').textContent = t.dataset.mass;
      info.querySelector('#pt-block').textContent = t.dataset.block;
      document.getElementById('pt-big').style.background = getComputedStyle(t).backgroundImage || getComputedStyle(t).backgroundColor;
    };
    grid.addEventListener('mouseover', e=>{ const t=e.target.closest('.elem'); if(t) setInfo(t); });
    grid.addEventListener('click', e=>{ const t=e.target.closest('.elem'); if(t) setInfo(t); });
  })();
  </script>

  <!-- UI logic -->
  <script src="app.js" defer></script>
</body>
</html>





