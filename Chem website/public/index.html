<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ChemBot — Problem Solver</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="hero">
    <div class="wrap">
      <h1>ChemBot</h1>
      <p class="lead">Fast, free, on-device chemistry tools — balanced equations, VSEPR shapes, and simple drawings. No AI key required.</p>
    </div>
  </header>

  <main class="wrap">

    <!-- Periodic Table -->
    <section class="card">
      <div class="section-head">
        <h2>Periodic Table</h2>
        <div class="legend">
          <span class="chip alkali">Alkali</span>
          <span class="chip alkaline">Alkaline Earth</span>
          <span class="chip transition">Transition</span>
          <span class="chip post">Post-Transition</span>
          <span class="chip metalloid">Metalloid</span>
          <span class="chip nonmetal">Nonmetal</span>
          <span class="chip halogen">Halogen</span>
          <span class="chip noble">Noble Gas</span>
          <span class="chip lanth">Lanthanide</span>
          <span class="chip act">Actinide</span>
        </div>
      </div>

      <!-- Hover card -->
      <div class="pt-info" id="pt-info" hidden>
        <div class="pt-big" id="pt-big">
          <div class="num" id="pt-num">—</div>
          <div class="sym" id="pt-sym">—</div>
          <div class="name" id="pt-name">Hover an element</div>
        </div>
        <div class="pt-props">
          <div>Atomic Mass (u) — <b id="pt-mass">—</b></div>
          <div>Symbol — <b id="pt-sym2">—</b></div>
          <div>Chemical Group Block — <b id="pt-block">—</b></div>
        </div>
      </div>

      <!-- Real 18×7 grid + f-block rows -->
      <div id="ptable" class="ptable"></div>
      <div class="fblock-note">* Lanthanides and Actinides shown below</div>
    </section>

<section id="home" class="grid home-grid">
  <a class="nav-card" href="#/eq"   data-view="eq">
    <h3>Equation Builder</h3>
    <p>Balance and predict products. ΔH°rxn from ΔH°f when available.</p>
  </a>
  <a class="nav-card" href="#/vsepr" data-view="vsepr">
    <h3>VSEPR Shapes</h3>
    <p>Electron & molecular geometry + white SVG sketch.</p>
  </a>
  <a class="nav-card" href="#/draw" data-view="draw">
    <h3>Element Drawings</h3>
    <p>Bohr / Bohr-Rutherford / Lewis (with electrons).</p>
  </a>
  <a class="nav-card" href="#/aufbau" data-view="aufbau">
  <h3>Aufbau (Orbital Diagram)</h3>
  <p>Electron configuration + orbital boxes (↑/↓, Hund).</p>
</a>
 <a class="nav-card" href="#/stoich" data-view="stoich">
  <h3>Stoichiometry</h3>
  <p>Mass ↔ moles, solutions (M), and gases (PV=nRT) with any reaction.</p>
</a> 
</section>
    
    <!-- Solvers -->
    <section class="grid solver-grid">
      <!-- Equation -->
      <section id="eq" class="view" hidden>
 <button class="back"><a href="/" style="color:inherit;text-decoration:none;">← Back</a></button>
      <div class="card solver">
        <h3>Equation Builder</h3>
        <p class="muted">Enter reactants (with optional products). Examples: <code>Zn + CuSO4</code>, <code>H2 + O2 → H2O</code></p>
        <div class="form">
          <input id="eq-react" type="text" placeholder="e.g., H2 + O2 -> H2O">
          <button id="eq-run" class="primary">Balance</button>
        </div>
        <pre id="eq-out" class="result"></pre>
      </div>
</section>
        
      <!-- VSEPR -->
      <section id="vsepr" class="view" hidden>
  <button class="back"><a href="/" style="color:inherit;text-decoration:none;">← Back</a></button>
      <div class="card solver">
        <h3>VSEPR Shape</h3>
        <p class="muted">Give a formula or keyword. Examples: <code>NH3</code>, <code>CO2</code>, <code>C (graphite)</code></p>
        <div class="form">
          <input id="vs-input" type="text" placeholder="e.g., NH3">
          <button id="vs-run" class="primary">Analyze</button>
        </div>
        <div id="vs-svg" class="svgwrap"></div>
        <pre id="vs-out" class="result"></pre>
      </div>
</section>
        
      <!-- Drawings -->
      <section id="draw" class="view" hidden>
  <button class="back"><a href="/" style="color:inherit;text-decoration:none;">← Back</a></button>
      <div class="card solver">
        <h3>Element Drawings</h3>
        <p class="muted">Simple Bohr / Bohr-Rutherford / Lewis diagrams (first 20 elements supported for now).</p>
        <div class="form">
          <select id="draw-symbol"></select>
          <button id="draw-run" class="primary">Draw</button>
        </div>
        <div class="draw-grid">
          <div><h4>Bohr</h4><div id="svg-bohr" class="svgwrap"></div></div>
          <div><h4>Bohr-Rutherford</h4><div id="svg-br" class="svgwrap"></div></div>
          <div><h4>Lewis</h4><div id="svg-lewis" class="svgwrap"></div></div>
        </div>
        <p id="draw-notes" class="muted" style="margin-top:.6rem;"></p>
      </div>
        </section>

<!-- Aufbau -->
<section id="aufbau" class="view" hidden>
  <button class="back"><a href="/" style="color:inherit;text-decoration:none;">← Back</a></button>
  <div class="card solver">
    <h3>Aufbau (Orbital Diagram)</h3>
    <p class="muted">Enter element symbol or atomic number. Uses noble-gas shorthand and applies common d-block exceptions (Cr, Cu, Mo, Ag, Pd...).</p>

    <div class="form">
      <input id="aufbau-input" type="text" placeholder="e.g., K or 19">
      <label class="chk">
        <input id="aufbau-shorthand" type="checkbox" checked>
        Use noble-gas shorthand
      </label>
      <button type="button" id="aufbau-run" class="primary">Build</button>
    </div>

  <div class="result" id="aufbau-text">
      <div id="auf-qn" class="mono muted" style="margin:0 0 .35rem 0;"></div>
      <div><b>Configuration:</b> <span id="aufbau-config"></span></div>
      <div><b>Shorthand:</b> <span id="aufbau-sh"></span></div>
    </div>

    <div id="aufbau-diagram" class="svgwrap" style="min-height:160px;">
      <!-- orbital boxes render here -->
    </div>
  </div>
</section>

      <!-- Soichiometry -->
<section id="stoich" class="view" hidden>
  <button class="back"><a href="/" style="color:inherit;text-decoration:none;">← Back</a></button>

  <div class="card solver">
    <h3>Stoichiometry</h3>
    <p class="muted">
  Enter a reaction (e.g., <code>C3H8 + O2 -> CO2 + H2O</code>).
  <b>Click “Parse reaction”</b> to load/update the species list; only then is the new reaction used.
</p>

    <div class="form">
      <label>Reaction</label>
      <input id="st-eq" type="text">

      <div class="grid2">
        <div>
          <label>Known species</label>
          <select id="st-known"></select>
        </div>
        <div>
          <label>Target species</label>
          <select id="st-target"></select>
        </div>
      </div>

      <div class="grid2">
        <div>
          <label>Known mode</label>
          <select id="st-known-mode">
            <option value="mol">Moles (mol)</option>
            <option value="mass">Mass (g)</option>
            <option value="solution">Solution (M·V)</option>
            <option value="gas">Gas (PV=nRT)</option>
          </select>
        </div>
        <div>
          <label>Output as</label>
          <select id="st-out-mode">
            <option value="mol">Moles (mol)</option>
            <option value="mass">Mass (g)</option>
            <option value="solution">Solution volume (L at M)</option>
            <option value="gas">Gas volume (L at P,T)</option>
          </select>
        </div>
      </div>

      <!-- Known inputs -->
      <div id="st-known-fields">
        <!-- mol -->
        <div class="mode mode-mol">
          <label>n (mol)</label>
          <input id="st-known-mol" type="number" step="any" placeholder="e.g., 0.50">
        </div>
        <!-- mass -->
        <div class="mode mode-mass" hidden>
          <label>m (g)</label>
          <input id="st-known-g" type="number" step="any" placeholder="e.g., 44.0">
        </div>
        <!-- solution -->
        <div class="mode mode-solution" hidden>
          <div class="grid2">
            <div><label>M (mol/L)</label><input id="st-known-M" type="number" step="any" placeholder="e.g., 1.0"></div>
            <div><label>V (L)</label><input id="st-known-VL" type="number" step="any" placeholder="e.g., 0.250"></div>
          </div>
        </div>
        <!-- gas -->
        <div class="mode mode-gas" hidden>
  <div class="grid3">
    <div><label>P (kPa)</label><input id="st-P" type="number" step="any" placeholder="e.g., 101.3"></div>
    <div><label>V (L)</label><input id="st-V" type="number" step="any" placeholder="e.g., 2.00"></div>
    <div><label>T (K)</label><input id="st-T" type="number" step="any" placeholder="e.g., 298"></div>
  </div>
</div>

      <!-- Output conditions -->
      <!-- Output conditions -->
<div id="st-out-fields">
  <!-- Output as: Solution volume (L at M) -->
  <div class="mode mode-solution" hidden>
    <div class="grid1">
      <div>
        <label>M (mol/L)</label>
        <input id="st-out-M" type="number" step="any" placeholder="e.g., 0.50">
      </div>
    </div>
  </div>

  <!-- Output as: Gas volume (L at P,T) -->
  <div class="mode mode-gas" hidden>
    <div class="grid3">
      <div>
        <label>P (kPa)</label>
        <input id="st-out-P" type="number" step="any" placeholder="e.g., 101.3">
      </div>
      <div>
        <label>T (K)</label>
        <input id="st-out-T" type="number" step="any" placeholder="e.g., 298">
      </div>
      <div style="align-self:end;opacity:.8;">
        Uses R = 8.314 kPa·L·mol⁻¹·K⁻¹
      </div>
    </div>
  </div>
</div>
      </div>

      <div>
        <button id="st-parse" type="button">Parse reaction</button>
        <button id="st-run" class="primary" type="button">Compute</button>
      </div>
    </div>

    <div class="result" id="st-result"></div>
  </div>
</section>
    
    </section>
    
  </main>

  <!-- ===== Local data & solvers (one time) ===== -->
<script>
  // Atomic number + VALENCE ELECTRONS (VE) for first 20
  window.PERIODIC = {
    Z:{H:1,He:2,Li:3,Be:4,B:5,C:6,N:7,O:8,F:9,Ne:10,Na:11,Mg:12,Al:13,Si:14,P:15,S:16,Cl:17,Ar:18,K:19,Ca:20},
    VE:{H:1,He:2,Li:1,Be:2,B:3,C:4,N:5,O:6,F:7,Ne:8,Na:1,Mg:2,Al:3,Si:4,P:5,S:6,Cl:7,Ar:8,K:1,Ca:2}
  };
</script>
<script>
(()=>{ // LocalChem v2 — products, ΔH°rxn via ΔH°f, mechanisms

  /* ========== Utilities ========== */
  function parseFormula(f){const s=[{}];const r=/([A-Z][a-z]?|\(|\)|\d+)/g;let m;
    while((m=r.exec(f))){const t=m[1];
      if(t==='('){s.push({});continue}
      if(t===')'){const top=s.pop();const mult=/^\d+/.exec(f.slice(r.lastIndex))?.[0];const k=mult?parseInt(mult,10):1;if(mult)r.lastIndex+=mult.length;for(const e in top)s[s.length-1][e]=(s[s.length-1][e]||0)+top[e]*k;continue}
      if(/^\d+$/.test(t))continue;const el=t;const mult=/^\d+/.exec(f.slice(r.lastIndex))?.[0];const k=mult?parseInt(mult,10):1;if(mult)r.lastIndex+=mult.length;s[s.length-1][el]=(s[s.length-1][el]||0)+k
    }return s[0]}
  function parseSide(side){return side.split('+').map(x=>{const t=x.trim();const m=/^\s*(\d+)\s+(.+)$/.exec(t);return m?{coef:parseInt(m[1],10),formula:m[2].trim()}:{coef:1,formula:t}})}
  function buildMatrix(lhs,rhs){const sp=[...lhs,...rhs],els=new Set();sp.forEach(p=>{p.comp=parseFormula(p.formula);Object.keys(p.comp).forEach(k=>els.add(k))});
    const e=[...els],C=sp.length,R=e.length,A=[...Array(R)].map(()=>Array(C).fill(0));
    e.forEach((el,i)=>{lhs.forEach((p,j)=>A[i][j]=p.comp[el]||0);rhs.forEach((p,j)=>A[i][j+lhs.length]=-(p.comp[el]||0))});
    return {A,lhs,rhs}}
  function balanceEquation(input){
    const [L,R]=input.split('->').map(s=>s.trim()); if(!L||!R) throw new Error("Use 'reactants -> products'");
    const lhs=parseSide(L), rhs=parseSide(R), {A}=buildMatrix(lhs,rhs);
    const rows=A.length+1, cols=A[0].length, M=[...Array(rows)].map(()=>Array(cols).fill(0));
    for(let i=0;i<A.length;i++)for(let j=0;j<cols;j++)M[i][j]=A[i][j];
    M[rows-1][cols-1]=1; const b=Array(rows).fill(0); b[rows-1]=1;
    const aug=M.map((row,i)=>row.concat([b[i]]));
    const gcd=(a,b)=>b?gcd(b,a%b):Math.abs(a); const lcm=(a,b)=>Math.abs(a*b)/gcd(a,b);
    for(let col=0,row=0;col<cols&&row<rows;col++){
      let piv=row; while(piv<rows&&aug[piv][col]===0)piv++; if(piv===rows)continue;
      [aug[row],aug[piv]]=[aug[piv],aug[row]]; const pv=aug[row][col];
      for(let c=col;c<=cols;c++)aug[row][c]/=pv;
      for(let r=0;r<rows;r++){ if(r===row)continue; const f=aug[r][col]; if(f!==0) for(let c=col;c<=cols;c++)aug[r][c]-=f*aug[row][c]; }
      row++;
    }
    const x=aug.slice(0,cols).map(r=>r[cols]||0);
    const den=x.map(v=>{const s=v.toString();return s.includes('.')?10**s.split('.')[1].length:1});
    const LCM=den.reduce((p,c)=>lcm(p,c),1); let nums=x.map(v=>Math.round(v*LCM));
    const G=nums.reduce((p,c)=>gcd(p,c),nums[0]||1); nums=nums.map(v=>Math.abs(v/G));
    const left=lhs.map((p,i)=>({coef:nums[i], formula:p.formula}));
    const right=rhs.map((p,i)=>({coef:nums[i+lhs.length], formula:p.formula}));
    const lstr=left.map(p=>`${p.coef===1?'':p.coef+' '}${p.formula}`).join(' + ');
    const rstr=right.map(p=>`${p.coef===1?'':p.coef+' '}${p.formula}`).join(' + ');
    return {balanced:`${lstr} -> ${rstr}`, left, right};
  }

  /* ========== ΔH°f database (kJ/mol at 298 K) — extendable ========== */
  const Hf = {
    "H2(g)":0, "O2(g)":0, "N2(g)":0, "Cl2(g)":0, "HCl(aq)":-167.2,
    "H2O(l)":-285.8, "H2O(g)":-241.8, "CO2(g)":-393.5, "CO(g)":-110.5,
    "CH4(g)":-74.8, "C2H6(g)":-84.0, "C2H4(g)":52.3, "C2H2(g)":226.7,
    "NaOH(aq)":-469.6, "NaCl(s)":-411.2, "NaCl(aq)":-407.3,
    "CuSO4(aq)":-769.9, "ZnSO4(aq)":-980.0, "Cu(s)":0, "Zn(s)":0,
    "CaCO3(s)":-1206.9, "CaO(s)":-635.1, "SO2(g)":-296.8, "SO3(g)":-395.7,
    "NH3(g)":-46.1, "NO2(g)":33.2, "H2SO4(aq)":-909.3
  };
  function HfLookup(species){
    // try exact, then assume (g), then (aq), then (s)
    if(Hf[species]!==undefined) return Hf[species];
    const base = species.replace(/\s+/g,'');
    for(const phase of ["(g)","(aq)","(l)","(s)"]){
      const k = `${base}${phase}`; if(Hf[k]!==undefined) return Hf[k];
    }
    return null;
  }
  function deltaH_from_Hf(left,right){
    // ΔH°rxn = Σν Hf(products) − Σν Hf(reactants)
    let prod=0, react=0;
    for(const p of right){
      const v=HfLookup(p.formula); if(v===null) return {dH:null, note:"ΔH°f unavailable for at least one product."};
      prod += v * p.coef;
    }
    for(const r of left){
      const v=HfLookup(r.formula); if(v===null) return {dH:null, note:"ΔH°f unavailable for at least one reactant."};
      react += v * r.coef;
    }
    return {dH: Math.round((prod-react)*10)/10, note:"Calculated from tabulated ΔH°f (kJ/mol)."};
  }

  /* ========== Product prediction (simple but useful) ========== */
  const METALS = new Set(["Li","Na","K","Rb","Cs","Mg","Ca","Sr","Ba","Al","Zn","Fe","Cu","Ag","Au","Ni","Co","Sn","Pb"]);
  const COMMON_ANIONS = ["Cl","Br","I","NO3","SO4","CO3","OH","PO4","F","CN"];

  function isO2(x){return x.replace(/\s+/g,'').toUpperCase()==="O2";}
  function hydrocarbonLike(x){
    const m=/^C(\d*)(H\d+)(O\d+)?$/i.exec(x.replace(/\s+/g,''));
    if(!m) return null;
    const C=parseInt(m[1]||"1",10), hasO=!!m[3];
    return {C, hasO};
  }
  function isAcid(x){ return /^H[A-Z]/.test(x) && !/^H2O$/.test(x); }
  function isHydroxide(x){ return /OH/.test(x) && !/^H2O$/.test(x); }
  function isMetalElement(x){ return METALS.has(x.replace(/\s+/g,'')); }

function predictProducts(reactants){
  const R = reactants.map(s=>s.trim());

  // helpers
  const hasO2 = R.some(x=>x.replace(/\s+/g,'').toUpperCase()==="O2");
  const HC = R.find(x=>/^C\d*H\d*(O\d*)?$/i.test(x.replace(/\s+/g,'')));

  // quick acid/base test
  const isAcid = x => /^H[A-Z]/.test(x) && !/^H2O$/.test(x);
  const isBase = x => /(OH)/.test(x) && !/^H2O$/.test(x);

  // Δ— COMBUSTION
  if (hasO2 && HC) {
    return { type:"combustion", products:["CO2(g)","H2O(l)"], mechanism:[
      "Oxidation of C/H framework to CO2 and H2O"
    ]};
  }
  if (hasO2 && R.includes("C")) return { type:"oxidation", products:["CO2(g)"], mechanism:["Carbon oxidized to CO2"] };
  if (hasO2 && R.includes("S")) return { type:"oxidation", products:["SO2(g)"], mechanism:["Sulfur oxidized to SO2"] };

// — ACID–BASE
if (R.some(isAcid) && R.some(isBase)) {
  const acid = R.find(isAcid), base = R.find(isBase);
  const acidAnion = acid.replace(/^H/,'');                 // e.g., HCl → Cl
  const baseCat = (/^([A-Z][a-z]?)/.exec(base)||[])[1] || "Na";
  return {
    type: "acid-base",
    products: [`${baseCat}${acidAnion}(aq)`, "H2O(l)"],
    mechanism: [
      `${acid} ⇌ H⁺ + ${acidAnion}⁻`,
      `${base} ⇌ ${baseCat}⁺ + OH⁻`,
      `H⁺ + OH⁻ → H2O`,
      `${baseCat}⁺ + ${acidAnion}⁻ → ${baseCat}${acidAnion}(aq)`
    ]
  };
}

  // Δ— SINGLE REPLACEMENT: M + M'X → M' + MX  (with charge balancing)
// --- charges
const METAL_CHARGE = {Li:1,Na:1,K:1,Rb:1,Cs:1,Fr:1,Mg:2,Ca:2,Sr:2,Ba:2,Zn:2,Fe:2,Cu:2,Ni:2,Co:2,Sn:2,Pb:2,Al:3,Ag:1};
const ANION_CHARGE = {Cl:-1,Br:-1,I:-1,F:-1,OH:-1,NO3:-1,CN:-1,SO4:-2,CO3:-2,SO3:-2,PO4:-3};
const isMetal = x => METAL_CHARGE[x] !== undefined;

// parse salts like "Fe2(SO4)3", "CuCl2", "Na2CO3"
const splitSalt = x => {
  const t = x.replace(/\s+/g,'');                     // kill spaces (handles "SO4 3")
  const m = /^([A-Z][a-z]?)(.*)$/.exec(t);            // cation symbol + rest
  if (!m) return null;
  const cation = m[1];
  let rest = (m[2] || "").replace(/^\d+/, "");        // drop any leading count like the "2" in Fe2(SO4)3

  // (SO4)3 style
  let anion = null, mult = 1;
  let pm = /^\(([^)]+)\)(\d+)$/.exec(rest);
  if (pm) { anion = pm[1]; mult = parseInt(pm[2],10); }
  else {
    const hit = Object.keys(ANION_CHARGE).find(a => rest.startsWith(a));
    if (hit) { anion = hit; mult = parseInt(rest.slice(hit.length)||"1",10); }
  }
  if (!anion) return null;
  return { cation, anion, mult };
};

function buildSalt(cation, anion){
  const zM = Math.max(1, METAL_CHARGE[cation] ?? 1);
  const zX = Math.abs(ANION_CHARGE[anion] ?? 1);
  const gcd = (a,b)=>b?gcd(b,a%b):Math.abs(a);
  const a = zX/gcd(zM,zX), b = zM/gcd(zM,zX);  // M_a X_b
  const poly = /[A-Z].*[A-Z]/.test(anion);
  const X = poly && b>1 ? `(${anion})${b}` : `${anion}${b===1?"":b}`;
  const M = `${cation}${a===1?"":a}`;
  return `${M}${X}(aq)`;
}

// — SINGLE REPLACEMENT: M + M'X → M' + MX
{
  const metal = R.find(isMetal);
  const salt  = R.map(splitSalt).find(Boolean);
  if (metal && salt) {
    const productSalt = buildSalt(metal, salt.anion);         // MX (charge-balanced)
    const displaced   = `${salt.cation}(s)`;                  // M' precipitates as metal

    // mechanism with actual symbols and charges
    const zM = METAL_CHARGE[metal] ?? 1;
    const zC = METAL_CHARGE[salt.cation] ?? 1;
    const ch = n => (n===1 ? "⁺" : `${n}⁺`);
    return {
      type: "single replacement (redox)",
      products: [productSalt, displaced],
      mechanism: [
        `${metal} → ${metal}${ch(zM)} + ${zM} e⁻`,
        `${salt.cation}${ch(zC)} + ${zC} e⁻ → ${salt.cation}(s)`
      ]
    };
  }
}

  // Δ— DOUBLE DISPLACEMENT (metathesis)
  const salts = R.map(splitSalt).filter(Boolean);
  if (salts.length===2){
    const [s1,s2]=salts;
    const AD = buildSalt(s1.cation, s2.anion);
    const CB = buildSalt(s2.cation, s1.anion);
    return { type:"double displacement", products:[AD,CB], mechanism:[
      "Dissociation in water", "Ion exchange", "Check precipitation/neutralization"
    ]};
  }

  // Δ— SIMPLE SYNTHESIS of two elements
  if (R.length===2 && R.every(x=>/^[A-Z][a-z]?$/.test(x))) {
    return { type:"synthesis", products:[`${R[0]}${R[1]}(s)`], mechanism:["Combination of elements"] };
  }

  return { type:"unknown", products:[], mechanism:[] };
}

  /* ========== Drawings (same as you have, white electrons) ========== */
  function shells(z){const s=[];let left=z;const cap=[2,8,8,18];for(let i=0;i<cap.length&&left>0;i++){const take=Math.min(cap[i],left);s.push(take);left-=take}return s}
  function bohrSVG(symbol,z){
    const sh=shells(z);
    const dots = sh.map((n,i)=>{
      const R=40+30*i;
      return Array.from({length:n}).map((_,k)=>{
        const a=(k/n)*2*Math.PI, x=200+R*Math.cos(a), y=150+R*Math.sin(a);
        return `<circle cx="${x.toFixed(1)}" cy="${y.toFixed(1)}" r="3" fill="#fff"/>`;
      }).join('');
    }).join('');
    return `<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
      <circle cx="200" cy="150" r="22" fill="#3a5dd9"/>
<text x="200" y="157" font-size="20" fill="#fff" text-anchor="middle">${symbol}</text>
      ${sh.map((_,i)=>`<circle cx="200" cy="150" r="${40+30*i}" stroke="#fff" stroke-width="2" fill="none"/>`).join('')}
      ${dots}
    </svg>`;
  }
  function bohr_rutherfordSVG(symbol, z) {
  const sh = shells(z);
  const MASS = PERIODIC.VEC?.[symbol] ?? (sh.at(-1)?.[0]||0); // fallback if needed
  const protons = z;
  const neutrons = MASS - z;

  const dots = sh.map((n,i)=>{
    const R=40+30*i;
    return Array.from({length:n}).map((_,k)=>{
      const a=(k/n)*2*Math.PI,
            x=200+R*Math.cos(a),
            y=150+R*Math.sin(a);
      return `<circle cx="${x.toFixed(1)}" cy="${y.toFixed(1)}" r="3" fill="#fff"/>`;
    }).join('');
  });

  return `<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
<circle cx="200" cy="150" r="30" fill="#3a5dd9"/>
<text x="200" y="145" font-size="18" fill="#fff" text-anchor="middle">${protons} P</text>
<text x="200" y="170" font-size="18" fill="#fff" text-anchor="middle">${neutrons} N</text>
${sh.map((_,i)=>`<circle cx="200" cy="150" r="${40+30*i}" stroke="#fff" stroke-width="2" fill="none"/>`).join('')}
${dots}
</svg>`;
}
  function lewisSVG(symbol,v){
    const pts = Array.from({length:v}).map((_,i)=>{
      const a=(i/v)*2*Math.PI, R=70, x=200+R*Math.cos(a), y=150+R*Math.sin(a);
      return `<circle cx="${x.toFixed(1)}" cy="${y.toFixed(1)}" r="5" fill="#fff"/>`;
    }).join('');
    return `<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
      <text x="200" y="160" text-anchor="middle" font-family="Inter,system-ui,sans-serif" font-size="64" fill="#fff">${symbol}</text>
      ${pts}
    </svg>`;
  }
  async function localDrawElement(symbol){
    const Z=PERIODIC.Z[symbol]; if(!Z) return {error:"Unknown element"};
    const sh=shells(Z); const v=(PERIODIC.VE?.[symbol] ?? (sh.at(-1)||0));
    return { valence_electrons:v, bohr:bohrSVG(symbol,Z), bohr_rutherford:bohr_rutherfordSVG(symbol,Z), lewis:lewisSVG(symbol,v), notes:"Bohr models with electrons; first 20 elements best supported." };
  }

  /* ---------- VSEPR (fixed: uses valence ELECTRONS) ---------- */
  const EG = {2:"linear",3:"trigonal planar",4:"tetrahedral",5:"trigonal bipyramidal",6:"octahedral"};

function countBonds(formula){
  const toks = (formula.replace(/\s+/g,'').match(/[A-Z][a-z]?\d*/g) || []);
  if (toks.length === 0) return { central: "X", bonds: 0 };

  // counts per element
  const counts = {};
  for (const tok of toks) {
    const el = /^[A-Z][a-z]?/.exec(tok)[0];
    const n  = parseInt(tok.slice(el.length) || "1", 10);
    counts[el] = (counts[el] || 0) + n;
  }
  const elements = Object.keys(counts);

  // Special case: homonuclear triatomic (e.g., O3) → E–E–E with central E and 2 bonds
  if (elements.length === 1 && Object.values(counts)[0] === 3) {
    const el = elements[0];
    return { central: el, bonds: 2 };
  }

  // choose first non-H token as central (simple heuristic)
  let central = null;
  for (const t of toks) {
    const el = /^[A-Z][a-z]?/.exec(t)[0];
    if (el !== "H") { central = el; break; }
  }
  central = central || /^[A-Z][a-z]?/.exec(toks[0])[0];

  // crude bond count = total atoms not equal to central element
  const bonds = Object.entries(counts).reduce((a,[el,n]) => el === central ? a : a + n, 0);
  return { central, bonds };
}

  function lonePairs(central, bonds){
    const VE = (window.PERIODIC.VE?.[central] ?? 4);           // valence electrons of central atom
    const lp = Math.max(0, Math.floor((VE - bonds)/2));        // lone pairs (integer)
    return lp;
  }

  function classifyGeometry(bonds, lp){
    const ed = bonds + lp;                    // electron domains
    const eg = EG[ed] || "unknown";          // electron geometry
    let mg = eg;                              // molecular geometry (default = eg)
    if(ed===3 && lp===1) mg="bent";
    if(ed===4 && lp===1) mg="trigonal pyramidal";
    if(ed===4 && lp===2) mg="bent";
    if(ed===5 && lp===1) mg="seesaw";
    if(ed===5 && lp===2) mg="T-shaped";
    if(ed===5 && lp===3) mg="linear";
    if(ed===6 && lp===1) mg="square pyramidal";
    if(ed===6 && lp===2) mg="square planar";
    return {eg, mg, ed};
  }

  // ===== VSEPR angle heuristics (kPa unrelated) =====
// domains = total electron domains around the central atom
// lp = lone pairs; bp = bonding pairs (domains - lp)
function vseprAngle(domains, lp, bp){
  // Two domains: linear
  if (domains === 2) return 180;

  // Three domains (trigonal planar baseline 120°)
  if (domains === 3){
    if (lp === 0) return 120;                // AX3
    if (lp === 1 && bp === 2) return 117;    // AX2E  (SO2-type bent)
  }

  // Four domains (tetra baseline 109.5°)
  if (domains === 4){
    if (lp === 0) return 109.5;              // AX4
    if (lp === 1 && bp === 3) return 107;    // AX3E  (NH3 trig pyramidal)
    if (lp === 2 && bp === 2) return 104.5;  // AX2E2 (H2O bent)
  }

  // Five domains (trig bipyramidal baseline ~120/90)
  if (domains === 5){
    if (lp === 0) return 120;                // report the equatorial average
    if (lp === 1 && bp === 4) return 102;    // seesaw (approx.)
    if (lp === 2 && bp === 3) return 90;     // T-shaped
    if (lp === 3 && bp === 2) return 180;    // linear
  }

  // Six domains (octa baseline 90°)
  if (domains === 6){
    if (lp === 0) return 90;                 // octahedral
    if (lp === 1 && bp === 5) return 90;     // square pyramidal (equatorial 90)
    if (lp === 2 && bp === 4) return 90;     // square planar
  }

  // Fallback
  return 109.5;
}
  
  function drawVSEPR(mg){
    const C="stroke='#fff' stroke-width='2' fill='none'", F="fill='#fff'";
    const center=`<circle ${F} cx="200" cy="150" r="6"/>`;
    const L=(pts)=>pts.map(([x,y])=>`<line ${C} x1="200" y1="150" x2="${x}" y2="${y}"/>`).join('');
    const B=(pts)=>pts.map(([x,y])=>`<circle ${F} cx="${x}" cy="${y}" r="6"/>`).join('');
    let pts=[];
    switch(mg){
      case "linear": pts=[[110,150],[290,150]]; break;
      case "trigonal planar": pts=[[200,70],[140,210],[260,210]]; break;
      case "bent": pts=[[150,200],[250,200]]; break;
      case "tetrahedral": pts=[[200,70],[110,200],[290,200],[200,230]]; break;
      case "trigonal pyramidal": pts=[[200,70],[130,210],[270,210]]; break;
      case "seesaw": pts=[[110,150],[290,150],[200,70],[200,230]]; break;
      case "T-shaped": pts=[[110,150],[290,150],[200,70]]; break;
      case "square planar": pts=[[140,110],[260,110],[140,190],[260,190]]; break;
      case "square pyramidal": pts=[[200,70],[140,110],[260,110],[140,190],[260,190]]; break;
      case "octahedral": pts=[[200,60],[200,240],[120,150],[280,150],[140,110],[260,190]]; break;
      default: pts=[[200,70],[140,210],[260,210]];
    }
    return `<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">${center}${L(pts)}${B(pts)}</svg>`;
  }

async function localSolveVSEPR(input){
  const f = input.trim().replace(/granite/ig,'graphite');

  // --- Special case: ozone O3 (3 domains: 2 bonding, 1 lone; sp2) ---
  if (/^O\s*3$/i.test(f)) {
    const eg = "trigonal planar", mg = "bent", ed = 3;
    const svg = drawVSEPR(mg);
    return {
      system: "molecule",
      formula: "O3",
      electron_geometry: eg,
      molecular_geometry: mg,
      electron_domains: `${ed} (2 bonding + 1 lone)`,
      bond_angles_deg: "~117°",
      hybridization: "sp2",
      svg
    };
  }

   // --- Generico: stima bonds e lone pairs, poi geometria e angolo ---
  const {central,bonds} = countBonds(f);
  const lp = lonePairs(central, bonds);
  const {eg, mg, ed} = classifyGeometry(bonds, lp);

  // calcolo dell’angolo in funzione di domini/lone-pairs
  const bp = ed - lp;
  const angle = vseprAngle(ed, lp, bp);

  // etichetta migliorata per AX2E2 (H2O): “bent (distorted tetrahedral)”
  let mgLabel = mg;
  if (ed === 4 && lp === 2 && mg === "bent") {
    mgLabel = "bent (distorted tetrahedral)";
  }

  const svg = drawVSEPR(mg);

  return {
    system: "molecule",
    formula: f,
    electron_geometry: eg,
    molecular_geometry: mgLabel,
    electron_domains: `${ed} (${bonds} bonding + ${lp} lone)`,
    bond_angles_deg: `~${angle}°`,
    hybridization:
      eg==="linear" ? "sp" :
      eg==="trigonal planar" ? "sp2" :
      eg==="tetrahedral" ? "sp3" :
      eg==="trigonal bipyramidal" ? "sp3d" :
      eg==="octahedral" ? "sp3d2" : "—",
    svg
  };
}

  /* ========== public API ========== */
  async function localSolveEquation(userInput){
  // normalize a few common “space before subscript” typos for polyatomics
  const norm = userInput
    .replace(/SO4\s*([2-9])/gi, '(SO4)$1')
    .replace(/NO3\s*([2-9])/gi, '(NO3)$1')
    .replace(/CO3\s*([2-9])/gi, '(CO3)$1')
    .replace(/PO4\s*([2-9])/gi, '(PO4)$1');

  // If user typed an arrow but no products, we still predict.
  if (norm.includes('->')) {
    const [L,R] = norm.split('->').map(s=>s.trim());
    if (!L) return { error: "Provide reactants before '->'." };
    if (!R) {
      const reactants = L.split('+').map(s=>s.trim()).filter(Boolean);
      const pred = predictProducts(reactants);
      if (!pred.products.length) return { error: "Couldn't predict products for those reactants." };
      const res = balanceEquation(`${reactants.join(' + ')} -> ${pred.products.join(' + ')}`);
      const dH = deltaH_from_Hf(res.left,res.right);
      return {
        balanced_equation: res.balanced,
        products: res.right.map(p=>p.formula),
        reaction_type: pred.type,
        enthalpy_kJ_per_mol: dH.dH,
        notes: dH.note,
        mechanism: pred.mechanism
      };
    }
    // Arrow with explicit products: just balance + ΔH°
    const res = balanceEquation(norm);
    const dH = deltaH_from_Hf(res.left,res.right);
    return {
      balanced_equation: res.balanced,
      products: res.right.map(p=>p.formula),
      reaction_type: "user-specified",
      enthalpy_kJ_per_mol: dH.dH,
      notes: dH.note,
      mechanism: []
    };
  }

  // No arrow: predict products then balance.
  const reactants = norm.split('+').map(s=>s.trim()).filter(Boolean);
  const pred = predictProducts(reactants);
  if (!pred.products.length) return { error: "Couldn't predict products for that input. Add products (A + B -> ...) or use a simpler pair." };
  const res = balanceEquation(`${reactants.join(' + ')} -> ${pred.products.join(' + ')}`);
  const dH = deltaH_from_Hf(res.left,res.right);
  return {
    balanced_equation: res.balanced,
    products: res.right.map(p=>p.formula),
    reaction_type: pred.type,
    enthalpy_kJ_per_mol: dH.dH,
    notes: dH.note,
    mechanism: pred.mechanism
  };
} 

/* ========= LocalChem: Aufbau / Orbital Diagrams ========= */
const LC_Aufbau = (()=>{

  const subshellOrder = [
    "1s","2s","2p","3s","3p","4s","3d","4p","5s","4d","5p",
    "6s","4f","5d","6p","7s","5f","6d","7p"
  ];
  const capacity = { s:2, p:6, d:10, f:14 };
  const boxes    = { s:1, p:3, d:5,  f:7  };

  const SYM = [
    "", "H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar",
    "K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr",
    "Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe",
    "Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu",
    "Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn",
    "Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr",
    "Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"
  ];
  const ZOF = Object.fromEntries(SYM.map((s,i)=>[s,i]).filter(([s])=>s));

  const noble = [
    {z:2,  tag:"[He]"},
    {z:10, tag:"[Ne]"},
    {z:18, tag:"[Ar]"},
    {z:36, tag:"[Kr]"},
    {z:54, tag:"[Xe]"},
    {z:86, tag:"[Rn]"},
    {z:118,tag:"[Og]"}
  ];

  function parseElement(inp){
    const s = String(inp||"").trim();
    if(!s) throw Error("Empty input");
    if(/^\d+$/.test(s)){ const z=+s; if(z<1||z>118) throw Error("Z out of range"); return { z, symbol: SYM[z] }; }
    const cap = s[0].toUpperCase() + (s[1]?.toLowerCase()||"");
    const z = ZOF[cap]; if(!z) throw Error("Unknown element symbol");
    return { z, symbol: cap };
  }

  function fillAufbau(Z){
    let remaining=Z; const occ={};
    for(const sp of subshellOrder){
      if(remaining<=0) break;
      const l=sp.slice(-1), cap=capacity[l], put=Math.min(cap,remaining);
      occ[sp]=put; remaining-=put;
    }
    // common d-block exceptions (d4→d5 s1, d9→d10 s1; Pd 4d10 5s0)
    for(const sp of ["3d","4d","5d"]){
      const sMap={ "3d":"4s", "4d":"5s", "5d":"6s" };
      const s = sMap[sp]; const v = occ[sp]||0;
      if((v===4 || v===9) && (occ[s]||0)>0){ occ[sp]=v+1; occ[s]=occ[s]-1; }
    }
    if(occ["4d"]===9 && occ["5s"]===1){ occ["4d"]=10; occ["5s"]=0; }
    return occ;
  }

  function configString(occ){
    return subshellOrder.filter(k=>occ[k]>0).map(k=>`${k}<sup>${occ[k]}</sup>`).join(" ");
  }
  function lastNoble(Z){ let base={z:0,tag:""}; for(const n of noble) if(n.z<=Z) base=n; return base; }
 // --- helper: build a full occupancy up to Z (already have fillAufbau) ---

  // NEW: compute shorthand by subtracting the noble-gas core OCCUPANCY (correct)
  function shorthand(occFull, Z){
    const base = lastNoble(Z);
    if (base.z === 0) return configString(occFull);
    const core = fillAufbau(base.z);           // occupancy of the core
    // diff = electrons beyond core, in each subshell
    const tail = [];
    for (const sp of subshellOrder) {
      const v = (occFull[sp] || 0) - (core[sp] || 0);
      if (v > 0) tail.push(`${sp}<sup>${v}</sup>`);
    }
    return `${base.tag} ${tail.join(" ")}`.trim();
  }

  // --- Hund filling into boxes: first ↑ one per box, then pair with ↓ ---
  function boxesFor(total, nboxes){
    const arr = Array.from({length: nboxes}, () => []);
    let e = total;
    for (let i = 0; i < nboxes && e > 0; i++, e--) arr[i].push('up');   // all ↑
    for (let i = 0; i < nboxes && e > 0; i++, e--) arr[i].push('down'); // then ↓
    return arr;
  }

  // display order: by principal n ascending, then s,p,d,f
  const LORDER = { s:0, p:1, d:2, f:3 };
  function sortByShell(a, b){
    const na = +a[0], nb = +b[0];
    if (na !== nb) return na - nb;
    return LORDER[a.slice(-1)] - LORDER[b.slice(-1)];
  }

// build rows in Madelung order, subtracting the core if shorthand is ON
function buildDiagram(occFull, Z, useSh = true){
  const rows = [];
  const core = useSh ? fillAufbau(lastNoble(Z).z) : {};

  // keep subshells in subshellOrder (Madelung) – matches shorthand sequence
  for (const sp of subshellOrder){
    const beyond = (occFull[sp] || 0) - (core[sp] || 0);
    if (beyond > 0){
      const nboxes = boxes[sp.slice(-1)];
      rows.push({ sp, boxes: boxesFor(beyond, nboxes) });
    }
  }
  return rows;
}

  // NEW: HTML like your picture — one big rectangle per subshell, inner boxes
  function diagramHTML(rows){
    const rowHtml = rows.map(r=>{
      const inner = r.boxes.map(pair=>{
        const arrows = pair.map(a => a === 'up' ? '↑' : '↓').join('');
        return `<div class="orb-box">${arrows}</div>`;
      }).join('');
      return `
        <div class="orb-row">
          <div class="orb-label">${r.sp}</div>
          <div class="orb-group">${inner}</div>
        </div>
      `;
    }).join('');
    return `<div class="orb-diagram">${rowHtml}</div>`;
  }

  // NEW: use the fixed pieces
  function localAufbau(input, useSh=true){
  const { z } = parseElement(input);
  const occ = fillAufbau(z);

  const cfg = configString(occ);
  const sh  = shorthand(occ, z);
  const dia = diagramHTML(buildDiagram(occ, z, useSh));

  const qn  = lastElectronQN(z);
  const qnHtml = qn
    ? `Quantum numbers (last e⁻ in <code>${qn.subshell}</code>): n = <b>${qn.n}</b>, l = <b>${qn.l}</b>, m<sub>ℓ</sub> = <b>${qn.m_l}</b>, m<sub>s</sub> = <b>${qn.m_s === 0.5 ? "+½" : "−½"}</b>`
    : '';

  return {
    configFullHtml: cfg,
    shorthandHtml:  sh,
    diagramHtml:    dia,
    qnHtml          // ← NEW
  };
}
// Map orbital letter to l
const LVAL = { s:0, p:1, d:2, f:3 };

// Quantum numbers for the last electron (ground state) of Z
function lastElectronQN(Z){
  // Full occupancy using your existing Aufbau filler (already handles exceptions)
  const occ = fillAufbau(Z);

  // Walk subshells in Madelung order until we reach Z electrons
  let cum = 0, chosen = null, eIndex = 0; // eIndex = position of the last electron inside the chosen subshell (1..2(2l+1))
  for (const sp of subshellOrder){
    const here = occ[sp] || 0;
    if (here <= 0) continue;
    if (cum + here >= Z){
      chosen = sp;
      eIndex = Z - cum;               // 1-based index within this subshell
      break;
    }
    cum += here;
  }
  if (!chosen) return null;           // Z=0 guard

  const n = parseInt(chosen, 10);
  const orb = chosen.slice(-1);
  const l = LVAL[orb];
  const nBoxes = 2*l + 1;

  // m_l list ordered from -l .. +l
  const mList = [];
  for (let m = -l; m <= l; m++) mList.push(m);

  let m_l, m_s;
  if (eIndex <= nBoxes){
    // first pass: all ↑ across boxes
    m_l = mList[eIndex - 1];
    m_s = +0.5;
  } else {
    // pairing pass: all ↓ in same order
    const idx = eIndex - nBoxes;      // 1..nBoxes
    m_l = mList[idx - 1];
    m_s = -0.5;
  }
  return { n, l, m_l, m_s, subshell: chosen, index: eIndex };
}
  
  return { localAufbau };
})();

/* ===== LocalChem: Stoichiometry engine ===== */
const LC_Stoich = (()=>{
  // --- atomic weights (IUPAC conventional) – handful of decimals is plenty
  const AW = {
    H:1.008, He:4.0026, Li:6.94, Be:9.0122, B:10.81, C:12.011, N:14.007, O:15.999, F:18.998, Ne:20.180,
    Na:22.990, Mg:24.305, Al:26.982, Si:28.085, P:30.974, S:32.06, Cl:35.45, Ar:39.948, K:39.098, Ca:40.078,
    Sc:44.956, Ti:47.867, V:50.942, Cr:51.996, Mn:54.938, Fe:55.845, Co:58.933, Ni:58.693, Cu:63.546, Zn:65.38,
    Ga:69.723, Ge:72.630, As:74.922, Se:78.971, Br:79.904, Kr:83.798, Rb:85.468, Sr:87.62, Y:88.906, Zr:91.224,
    Nb:92.906, Mo:95.95, Tc:98, Ru:101.07, Rh:102.91, Pd:106.42, Ag:107.87, Cd:112.41, In:114.82, Sn:118.71,
    Sb:121.76, Te:127.60, I:126.90, Xe:131.29, Cs:132.91, Ba:137.33, La:138.91, Ce:140.12, Pr:140.91, Nd:144.24,
    Sm:150.36, Eu:151.96, Gd:157.25, Tb:158.93, Dy:162.50, Ho:164.93, Er:167.26, Tm:168.93, Yb:173.05, Lu:174.97,
    Hf:178.49, Ta:180.95, W:183.84, Re:186.21, Os:190.23, Ir:192.22, Pt:195.08, Au:196.97, Hg:200.59, Tl:204.38,
    Pb:207.2, Bi:208.98, Po:209, At:210, Rn:222, Fr:223, Ra:226, Ac:227, Th:232.04, Pa:231.04, U:238.03,
    Np:237, Pu:244, Am:243, Cm:247, Bk:247, Cf:251, Es:252, Fm:257, Md:258, No:259, Lr:262
  };

  // Parse formula to element counts; supports parentheses and multipliers
  function parseFormula(f){
    let i=0;
    function parseGroup(){
      const counts = {};
      while(i < f.length){
        if(f[i] === ')'){ break; }
        if(f[i] === '('){
          i++; const inner = parseGroup();
          if(f[i] !== ')') throw Error("Missing ')'");
          i++;
          const mult = readNum();
          mulAdd(counts, inner, mult||1);
          continue;
        }
        const el = readEl();
        const n  = readNum() || 1;
        counts[el] = (counts[el]||0) + n;
      }
      return counts;
    }
    function readEl(){
      if(!/[A-Z]/.test(f[i])) throw Error("Bad element in formula");
      let el = f[i++]; if(i<f.length && /[a-z]/.test(f[i])) el += f[i++];
      return el;
    }
    function readNum(){
      let s=""; while(i<f.length && /[0-9]/.test(f[i])) s += f[i++];
      return s ? +s : 0;
    }
    function mulAdd(dst,src,m){
      for(const k in src) dst[k]=(dst[k]||0)+src[k]*m;
    }
    const res = parseGroup();
    if(i!==f.length) throw Error("Unexpected token in formula");
    return res;
  }

  function molarMass(formula){
    const c = parseFormula(formula);
    let mm = 0;
    for(const el in c){
      if(!(el in AW)) throw Error(`Missing atomic weight for ${el}`);
      mm += AW[el]*c[el];
    }
    return mm;
  }

  // Split reaction string → raw species (preserves written coeffs if present)
  function splitReaction(s){
    const [L,R] = s.replace(/→/g,'->').split('->').map(x=>x.trim());
    const left  = L.split('+').map(x=>x.trim()).filter(Boolean);
    const right = R.split('+').map(x=>x.trim()).filter(Boolean);
    return { left, right };
  }

  // Use your balancer when possible; fall back to written coeffs
  function balanceReaction(s){
    try {
    const res = window.LocalChem.balanceEquation(s);   // ← use your exact balancer
    const species = res.left.map(p=>p.formula).concat(res.right.map(p=>p.formula));
    const coeffs  = res.left.map(p=>p.coef)  .concat(res.right.map(p=>p.coef));
    return { species, coeffs };
  } catch {
    // very last-resort fallback: treat everything as 1
    const {left,right} = splitReaction(s);
    const all = left.concat(right);
    return { species: all, coeffs: all.map(()=>1) };
  }
  }

  const R = 8.314462618; // kPa·L·K^-1·mol^-1

  // Ideal gas helpers (P in kPa, V in L, T in K, n in mol)
  function gasMolesFromPVT(P_kPa, V_L, T_K){
    if (!(P_kPa > 0 && V_L > 0 && T_K > 0)) {
      throw Error("Gas P, V and T must all be > 0.");
    }
    return (P_kPa * V_L) / (R * T_K);   // n = PV / (RT)
  }

  function gasVolumeFromNPT(n_mol, P_kPa, T_K){
    if (!(n_mol > 0 && P_kPa > 0 && T_K > 0)) {
      throw Error("Gas n, P and T must all be > 0.");
    }
    return (n_mol * R * T_K) / P_kPa;   // V = nRT / P
  }
  
  function stoichCompute({ eq, knownSp, targetSp, knownMode, knownVals, outMode, outVals }){
    // 1) get balanced species+coeffs
    const { species, coeffs } = balanceReaction(eq);
    const idxK = species.findIndex(s=> s.replace(/\s+/g,'') === knownSp.replace(/\s+/g,''));
    const idxT = species.findIndex(s=> s.replace(/\s+/g,'') === targetSp.replace(/\s+/g,''));
    if(idxK<0 || idxT<0) throw Error("Selected species not found in reaction");

    // 2) moles of known
    let nKnown = 0;
    if(knownMode === 'mol'){
      nKnown = +knownVals.n;
    } else if(knownMode === 'mass'){
      const mm = molarMass(knownSp);
      nKnown = (+knownVals.g) / mm;
    } else if(knownMode === 'solution'){
      nKnown = (+knownVals.M) * (+knownVals.VL);
    } else if(knownMode === 'gas'){
      const P = +knownVals.P, V = +knownVals.V, T = +knownVals.T;
      nKnown = gasMolesFromPVT(P, V, T);
    } else { throw Error("Unknown known mode"); }
    if(!isFinite(nKnown) || nKnown<=0) throw Error("Known amount is invalid");

    // 3) stoichiometric ratio
    const nk = coeffs[idxK], nt = coeffs[idxT];
    const nTarget = nKnown * (nt/nk);

    // 4) convert to output
    let value = 0, unit = '';
    if(outMode === 'mol'){
      value = nTarget; unit = 'mol';
    } else if(outMode === 'mass'){
      value = nTarget * molarMass(targetSp); unit = 'g';
    } else if(outMode === 'solution'){
      const M = +outVals.M; if(!(M>0)) throw Error("Output molarity M is required");
      value = nTarget / M; unit = 'L';
    } else if(outMode === 'gas'){
      const P = +outVals.P, T = +outVals.T;
      value = gasVolumeFromNPT(nTarget, P, T);
      unit = 'L';
    } else { throw Error("Unknown output mode"); }

    return {
      species, coeffs, nKnown, nTarget, value, unit
    };
  }

  return { molarMass, parseFormula, balanceReaction, stoichCompute };
})();
  
  window.LocalChem = {
    localSolveEquation,
    localDrawElement,
    localSolveVSEPR,
    localAufbau: LC_Aufbau.localAufbau,
    balanceEquation,        // ← expose the raw balancer
    stoich: LC_Stoich
  };
})();
</script>

  <!-- Table renderer -->
  <script>
  (()=>{
    const grid = document.getElementById('ptable');
    if(!grid) return;

    // 18×7 main grid with explicit gaps, then row8/9 for f-block
    grid.style.setProperty('--cols', 18);

    // dataset: [Z, sym, name, mass, col, row, block]
    const main = [
      [1,"H","Hydrogen",1.008,1,1,"Nonmetal"],
      [2,"He","Helium",4.0026,18,1,"Noble Gas"],
      [3,"Li","Lithium",6.94,1,2,"Alkali Metal"],[4,"Be","Beryllium",9.0122,2,2,"Alkaline Earth Metal"],
      [5,"B","Boron",10.81,13,2,"Metalloid"],[6,"C","Carbon",12.011,14,2,"Nonmetal"],[7,"N","Nitrogen",14.007,15,2,"Nonmetal"],[8,"O","Oxygen",15.999,16,2,"Nonmetal"],[9,"F","Fluorine",18.998,17,2,"Halogen"],[10,"Ne","Neon",20.18,18,2,"Noble Gas"],
      [11,"Na","Sodium",22.99,1,3,"Alkali Metal"],[12,"Mg","Magnesium",24.305,2,3,"Alkaline Earth Metal"],
      [13,"Al","Aluminum",26.982,13,3,"Post-Transition Metal"],[14,"Si","Silicon",28.085,14,3,"Metalloid"],[15,"P","Phosphorus",30.974,15,3,"Nonmetal"],[16,"S","Sulfur",32.06,16,3,"Nonmetal"],[17,"Cl","Chlorine",35.45,17,3,"Halogen"],[18,"Ar","Argon",39.95,18,3,"Noble Gas"],
      [19,"K","Potassium",39.098,1,4,"Alkali Metal"],[20,"Ca","Calcium",40.078,2,4,"Alkaline Earth Metal"],
      [21,"Sc","Scandium",44.956,3,4,"Transition Metal"],[22,"Ti","Titanium",47.867,4,4,"Transition Metal"],[23,"V","Vanadium",50.942,5,4,"Transition Metal"],[24,"Cr","Chromium",51.996,6,4,"Transition Metal"],[25,"Mn","Manganese",54.938,7,4,"Transition Metal"],[26,"Fe","Iron",55.845,8,4,"Transition Metal"],[27,"Co","Cobalt",58.933,9,4,"Transition Metal"],[28,"Ni","Nickel",58.693,10,4,"Transition Metal"],[29,"Cu","Copper",63.546,11,4,"Transition Metal"],[30,"Zn","Zinc",65.38,12,4,"Transition Metal"],
      [31,"Ga","Gallium",69.723,13,4,"Post-Transition Metal"],[32,"Ge","Germanium",72.63,14,4,"Metalloid"],[33,"As","Arsenic",74.922,15,4,"Metalloid"],[34,"Se","Selenium",78.971,16,4,"Nonmetal"],[35,"Br","Bromine",79.904,17,4,"Halogen"],[36,"Kr","Krypton",83.798,18,4,"Noble Gas"],
      [37,"Rb","Rubidium",85.468,1,5,"Alkali Metal"],[38,"Sr","Strontium",87.62,2,5,"Alkaline Earth Metal"],
      [39,"Y","Yttrium",88.906,3,5,"Transition Metal"],[40,"Zr","Zirconium",91.224,4,5,"Transition Metal"],[41,"Nb","Niobium",92.906,5,5,"Transition Metal"],[42,"Mo","Molybdenum",95.95,6,5,"Transition Metal"],[43,"Tc","Technetium",98,7,5,"Transition Metal"],[44,"Ru","Ruthenium",101.07,8,5,"Transition Metal"],[45,"Rh","Rhodium",102.906,9,5,"Transition Metal"],[46,"Pd","Palladium",106.42,10,5,"Transition Metal"],[47,"Ag","Silver",107.868,11,5,"Transition Metal"],[48,"Cd","Cadmium",112.414,12,5,"Transition Metal"],[49,"In","Indium",114.818,13,5,"Post-Transition Metal"],[50,"Sn","Tin",118.71,14,5,"Post-Transition Metal"],[51,"Sb","Antimony",121.76,15,5,"Metalloid"],[52,"Te","Tellurium",127.6,16,5,"Metalloid"],[53,"I","Iodine",126.904,17,5,"Halogen"],[54,"Xe","Xenon",131.293,18,5,"Noble Gas"],
      [55,"Cs","Cesium",132.905,1,6,"Alkali Metal"],[56,"Ba","Barium",137.33,2,6,"Alkaline Earth Metal"],
      [72,"Hf","Hafnium",178.49,4,6,"Transition Metal"],[73,"Ta","Tantalum",180.947,5,6,"Transition Metal"],[74,"W","Tungsten",183.84,6,6,"Transition Metal"],[75,"Re","Rhenium",186.207,7,6,"Transition Metal"],[76,"Os","Osmium",190.23,8,6,"Transition Metal"],[77,"Ir","Iridium",192.217,9,6,"Transition Metal"],[78,"Pt","Platinum",195.08,10,6,"Transition Metal"],[79,"Au","Gold",196.967,11,6,"Transition Metal"],[80,"Hg","Mercury",200.59,12,6,"Transition Metal"],[81,"Tl","Thallium",204.38,13,6,"Post-Transition Metal"],[82,"Pb","Lead",207.2,14,6,"Post-Transition Metal"],[83,"Bi","Bismuth",208.98,15,6,"Post-Transition Metal"],[84,"Po","Polonium",209,16,6,"Metalloid"],[85,"At","Astatine",210,17,6,"Halogen"],[86,"Rn","Radon",222,18,6,"Noble Gas"],
      [87,"Fr","Francium",223,1,7,"Alkali Metal"],[88,"Ra","Radium",226,2,7,"Alkaline Earth Metal"],
      [104,"Rf","Rutherfordium",267,4,7,"Transition Metal"],[105,"Db","Dubnium",268,5,7,"Transition Metal"],[106,"Sg","Seaborgium",269,6,7,"Transition Metal"],[107,"Bh","Bohrium",270,7,7,"Transition Metal"],[108,"Hs","Hassium",269,8,7,"Transition Metal"],[109,"Mt","Meitnerium",278,9,7,"Transition Metal"],[110,"Ds","Darmstadtium",281,10,7,"Transition Metal"],[111,"Rg","Roentgenium",282,11,7,"Transition Metal"],[112,"Cn","Copernicium",285,12,7,"Transition Metal"],[113,"Nh","Nihonium",286,13,7,"Post-Transition Metal"],[114,"Fl","Flerovium",289,14,7,"Post-Transition Metal"],[115,"Mc","Moscovium",290,15,7,"Post-Transition Metal"],[116,"Lv","Livermorium",293,16,7,"Post-Transition Metal"],[117,"Ts","Tennessine",294,17,7,"Halogen"],[118,"Og","Oganesson",295,18,7,"Noble Gas"]
    ];
    const lan = [[57,"La","Lanthanum"],[58,"Ce","Cerium"],[59,"Pr","Praseodymium"],[60,"Nd","Neodymium"],[61,"Pm","Promethium"],[62,"Sm","Samarium"],[63,"Eu","Europium"],[64,"Gd","Gadolinium"],[65,"Tb","Terbium"],[66,"Dy","Dysprosium"],[67,"Ho","Holmium"],[68,"Er","Erbium"],[69,"Tm","Thulium"],[70,"Yb","Ytterbium"],[71,"Lu","Lutetium"]];
    const act = [[89,"Ac","Actinium"],[90,"Th","Thorium"],[91,"Pa","Protactinium"],[92,"U","Uranium"],[93,"Np","Neptunium"],[94,"Pu","Plutonium"],[95,"Am","Americium"],[96,"Cm","Curium"],[97,"Bk","Berkelium"],[98,"Cf","Californium"],[99,"Es","Einsteinium"],[100,"Fm","Fermium"],[101,"Md","Mendelevium"],[102,"No","Nobelium"],[103,"Lr","Lawrencium"]];

    const blockClass = b=>{
      const k = b.toLowerCase();
      if(k.includes('alkali') && !k.includes('earth')) return 'pt-alkali';
      if(k.includes('alkaline')||k.includes('earth')) return 'pt-alkaline';
      if(k.includes('transition')) return 'pt-transition';
      if(k.includes('post')) return 'pt-post';
      if(k.includes('metalloid')) return 'pt-metalloid';
      if(k.includes('nonmetal')) return 'pt-nonmetal';
      if(k.includes('halogen')) return 'pt-halogen';
      if(k.includes('noble')) return 'pt-noble';
      if(k.includes('lanthan')) return 'pt-lanth';
      if(k.includes('actin')) return 'pt-act';
      return '';
    };

    // Render helper
    const makeTile = (Z,sym,name,mass,col,row,block)=>{
      const d = document.createElement('div');
      d.className = `elem ${blockClass(block)}`;
      d.style.gridColumn = col;
      d.style.gridRow = row;
      d.innerHTML = `
        <div class="num">${Z}</div>
        <div class="sym">${sym}</div>
        <div class="name">${name}</div>
        <div class="mass">${typeof mass==='number'?mass:''}</div>
      `;
      d.dataset.block=block; d.dataset.z=Z; d.dataset.sym=sym; d.dataset.name=name; d.dataset.mass = (mass??'—');
      return d;
    };

    // Draw main
    grid.innerHTML = '';
    main.forEach(e=>grid.appendChild(makeTile(...e)));

    // f-block rows 8 & 9
    lan.forEach((x,i)=>grid.appendChild(makeTile(x[0],x[1],x[2],undefined,3+i,8,'Lanthanide')));
    act.forEach((x,i)=>grid.appendChild(makeTile(x[0],x[1],x[2],undefined,3+i,9,'Actinide')));

    // Hover card
    const info = document.getElementById('pt-info');
    const setInfo = (t)=>{
      info.hidden = false;
      info.querySelector('#pt-num').textContent = t.dataset.z;
      info.querySelector('#pt-sym').textContent = t.dataset.sym;
      info.querySelector('#pt-name').textContent = t.dataset.name;
      info.querySelector('#pt-sym2').textContent = t.dataset.sym;
      info.querySelector('#pt-mass').textContent = t.dataset.mass;
      info.querySelector('#pt-block').textContent = t.dataset.block;
      document.getElementById('pt-big').style.background = getComputedStyle(t).backgroundImage || getComputedStyle(t).backgroundColor;
    };
    grid.addEventListener('mouseover', e=>{ const t=e.target.closest('.elem'); if(t) setInfo(t); });
    grid.addEventListener('click', e=>{ const t=e.target.closest('.elem'); if(t) setInfo(t); });
  })();
  </script>

  <!-- UI logic -->
  <script src="app.js" defer></script>
</body>
</html>






























