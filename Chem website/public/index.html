<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ChemBot ‚Äî Problem Solver</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root { --bg:#0b1020; --card:#111834; --text:#e9ecff; --muted:#aab0d6; --accent:#6ea8ff; --card2:#0d1333; }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family:Inter,system-ui,Arial; background:linear-gradient(180deg,#0b1020,#0e1430); color:var(--text); }
    .wrap{ max-width:1100px; margin:40px auto; padding:0 16px; }
    .hero{ text-align:center; margin-bottom:24px; }
    h1{ font-size:32px; margin:0 0 6px; }
    p.lead{ color:var(--muted); margin:0 0 24px; }
    .card{ background:var(--card); border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    .grid{ display:grid; gap:12px; }
    .solver-grid{ grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); margin-top:16px; }
    .solver{ background:var(--card2); border:1px solid #243063; border-radius:14px; padding:16px; cursor:pointer; transition:transform .08s ease; }
    .solver:hover{ transform:translateY(-2px); border-color:#3e58b3; }
    .solver h3{ margin:0 0 8px; font-size:18px; }
    .solver p{ margin:0; color:var(--muted); font-size:14px; }
    .footer{ text-align:center; color:#93a1d8; font-size:12px; margin-top:28px; }

    /* Periodic table */
    .ptable{ display:grid; grid-template-columns:repeat(18, minmax(28px, 1fr)); gap:6px; }
    .elem{ background:#0b1030; border:1px solid #243063; border-radius:10px; padding:6px; text-align:center; position:relative; }
    .elem .num{ position:absolute; top:4px; left:6px; font-size:10px; color:#8fa0de; }
    .elem .sym{ font-size:14px; font-weight:700; }
    .elem .name{ font-size:10px; color:#8fa0de; }
    .empty{ visibility:hidden; }

    /* Views */
    .view{ display:none; }
    .view.active{ display:block; }

    .form{ display:flex; gap:10px; }
    input[type=text], select{ flex:1; background:#0b1030; color:var(--text); border:1px solid #243063; border-radius:12px; padding:12px; }
    button{ background:var(--accent); color:#071122; border:0; padding:12px 16px; border-radius:12px; font-weight:600; cursor:pointer; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    .result{ margin-top:16px; background:#0b1030; padding:14px; border-radius:12px; border:1px solid #243063; white-space:pre-wrap; }
    .back{ background:#233066; margin-bottom:12px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .svgwrap{ margin-top:12px; background:#0b1030; border:1px solid #243063; border-radius:12px; padding:12px; }
    .cols{ display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:12px; }
  </style>
  <script>
  const API_BASE = "https://chem-problem-solver.onrender.com";
</script>
</head>
<body>
  <div class="wrap">
    <div class="hero">
      <h1>üî¨ ChemBot ‚Äî Problem Solver</h1>
      <p class="lead">A single-page toolkit for students: interactive periodic table and guided solvers. No chats, just answers.</p>
    </div>

    <!-- HOME VIEW -->
    <section id="home" class="view active">
      <div class="card" style="margin-bottom:16px;">
        <h2 style="margin:0 0 12px;">Periodic Table</h2>
        <div id="ptable" class="ptable"></div>
      </div>

      <div class="card">
        <h2 style="margin:0 0 8px;">Problem Solvers</h2>
        <div class="grid solver-grid">
          <div class="solver" data-view="equation">
            <h3>Equation Builder</h3>
            <p>Enter reactants ‚Üí products, balanced equation, type, and ŒîH estimate.</p>
          </div>
          <div class="solver" data-view="vsepr">
            <h3>Bond Shapes & VSEPR</h3>
            <p>Enter a molecule or allotrope (e.g., NH3, C (graphite)) ‚Üí shape, hybridization, SVG sketch.</p>
          </div>
          <div class="solver" data-view="drawings">
            <h3>Structure Drawings</h3>
            <p>Bohr, Bohr‚ÄëRutherford, and Lewis dot diagrams ‚Äî pick an element.</p>
          </div>
          <div class="solver" data-view="stoich">
            <h3>Stoichiometry Solver</h3>
            <p>Mass, moles, limiting reagent, percent yield. (Coming next)</p>
          </div>
          <div class="solver" data-view="solutions">
            <h3>Solutions & Concentration</h3>
            <p>Compute dilutions with <span class="mono">C‚ÇÅV‚ÇÅ = C‚ÇÇV‚ÇÇ</span>.</p>
          </div>
          <div class="solver" data-view="advanced">
            <h3>Advanced (University)</h3>
            <p>Thermo, quantum, spectroscopy, equilibrium ‚Äî structured solutions.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- EQUATION BUILDER VIEW -->
    <section id="equation" class="view">
      <button class="back" onclick="switchView('home')">‚Üê Back</button>
      <div class="card">
        <h2 style="margin:0 0 8px;">Equation Builder</h2>
        <p class="lead">Type reactants (e.g., <span class="mono">Zn + CuSO4</span>). The AI will balance, classify, and estimate ŒîH.</p>
        <div class="form">
          <input id="eq-react" type="text" placeholder="e.g., Zn + CuSO4" />
          <button id="eq-run">Solve</button>
        </div>
        <div id="eq-out" class="result">Results will appear here.</div>
      </div>
    </section>

    <!-- VSEPR VIEW -->
    <section id="vsepr" class="view">
      <button class="back" onclick="switchView('home')">‚Üê Back</button>
      <div class="card">
        <h2 style="margin:0 0 8px;">Bond Shapes & VSEPR</h2>
        <p class="lead">Enter a molecule or carbon allotrope (e.g., <span class="mono">NH3</span>, <span class="mono">CO2</span>, <span class="mono">C (graphite)</span>).</p>
        <div class="form">
          <input id="vs-input" type="text" placeholder="e.g., NH3" />
          <button id="vs-run">Analyze</button>
        </div>
        <div id="vs-out" class="result">Shape, hybridization, and notes will appear here.</div>
        <div id="vs-svg" class="svgwrap"></div>
      </div>
    </section>

    <!-- DRAWINGS VIEW -->
    <section id="drawings" class="view">
      <button class="back" onclick="switchView('home')">‚Üê Back</button>
      <div class="card">
        <h2 style="margin:0 0 8px;">Structure Drawings</h2>
        <div class="form">
          <select id="draw-symbol"></select>
          <button id="draw-run">Draw</button>
        </div>
        <div class="cols">
          <div>
            <h3>Bohr</h3>
            <div id="svg-bohr" class="svgwrap"></div>
          </div>
          <div>
            <h3>Bohr‚ÄëRutherford</h3>
            <div id="svg-br" class="svgwrap"></div>
          </div>
          <div>
            <h3>Lewis Dot</h3>
            <div id="svg-lewis" class="svgwrap"></div>
          </div>
        </div>
        <div id="draw-notes" class="result"></div>
      </div>
    </section>

    <!-- Placeholder VIEWS -->
    <section id="stoich" class="view">
      <button class="back" onclick="switchView('home')">‚Üê Back</button>
      <div class="card"><h2>Stoichiometry Solver</h2><p>Coming next ‚Äî tell me the fields you want (e.g., given mass, target product, etc.).</p></div>
    </section>

    <section id="solutions" class="view">
      <button class="back" onclick="switchView('home')">‚Üê Back</button>
      <div class="card"><h2>Solutions & Concentration</h2><p>Use the dilution identity <span class="mono">C‚ÇÅV‚ÇÅ = C‚ÇÇV‚ÇÇ</span>. (We can add inputs and calculator next.)</p></div>
    </section>

    <section id="advanced" class="view">
      <button class="back" onclick="switchView('home')">‚Üê Back</button>
      <div class="card">
        <h2>Advanced (University)</h2>
        <p class="lead">Pick a topic and describe your problem.</p>
        <div class="form">
          <select id="adv-topic">
            <option value="thermo">Thermodynamics</option>
            <option value="equilibrium">Chemical Equilibrium</option>
            <option value="spectroscopy">Spectroscopy</option>
            <option value="quantum">Quantum / MO Theory</option>
          </select>
          <input id="adv-prompt" type="text" placeholder="e.g., Calculate ŒîG for reaction at 298 K given ŒîH and ŒîS." />
          <button id="adv-run">Solve</button>
        </div>
        <div id="adv-out" class="result">Outline, formulas, and result will appear here.</div>
      </div>
    </section>

    <div class="footer">Built for learning. Answers only; no hazardous how‚Äëto instructions.</div>
  </div>

  <!-- A) minimal data (ONE TIME) -->
  <script>
  window.PERIODIC = {
    Z: {H:1, He:2, Li:3, Be:4, B:5, C:6, N:7, O:8, F:9, Ne:10, Na:11, Mg:12, Al:13, Si:14, P:15, S:16, Cl:17, Ar:18, K:19, Ca:20},
    valence: {H:1, He:0, Li:1, Be:2, B:3, C:4, N:3, O:2, F:1, Ne:0, Na:1, Mg:2, Al:3, Si:4, P:3, S:2, Cl:1, Ar:0, K:1, Ca:2}
  };
  window.BOND_ENERGY = {"H-H":436,"O=O":498,"C-H":413,"C-C":348,"C=C":614,"C‚â°C":839,"C=O":799,"O-H":463,"N‚â°N":945,"N-H":391,"C-O":358};
  </script>

  <!-- B) local solvers (ONE TIME) -->
  <script>
  (()=>{
    function parseFormula(f){const s=[{}];const r=/([A-Z][a-z]?|\(|\)|\d+)/g;let m;while((m=r.exec(f))){const t=m[1];if(t==='('){s.push({});continue}if(t===')'){const top=s.pop();const mult=/^\d+/.exec(f.slice(r.lastIndex))?.[0];const k=mult?parseInt(mult,10):1;if(mult)r.lastIndex+=mult.length;for(const e in top)s[s.length-1][e]=(s[s.length-1][e]||0)+top[e]*k;continue}if(/^\d+$/.test(t))continue;const el=t;const mult=/^\d+/.exec(f.slice(r.lastIndex))?.[0];const k=mult?parseInt(mult,10):1;if(mult)r.lastIndex+=mult.length;s[s.length-1][el]=(s[s.length-1][el]||0)+k}return s[0]}
    function parseSide(side){return side.split('+').map(x=>{const t=x.trim();const m=/^\s*(\d+)\s+(.+)$/.exec(t);return m?{coef:parseInt(m[1],10),formula:m[2].trim()}:{coef:1,formula:t}})}
    function buildMatrix(lhs,rhs){const sp=[...lhs,...rhs],els=new Set();sp.forEach(p=>{p.comp=parseFormula(p.formula);Object.keys(p.comp).forEach(k=>els.add(k))});const e=[...els],C=sp.length,R=e.length,A=[...Array(R)].map(()=>Array(C).fill(0));e.forEach((el,i)=>{lhs.forEach((p,j)=>A[i][j]=p.comp[el]||0);rhs.forEach((p,j)=>A[i][j+lhs.length]=-(p.comp[el]||0))});return {A,sp}}
    function balanceEquation(input){const [L,R]=input.split('->').map(s=>s.trim());if(!L||!R)throw new Error("Use 'reactants -> products'");const lhs=parseSide(L),rhs=parseSide(R);const {A}=buildMatrix(lhs,rhs);const rows=A.length+1,cols=A[0].length,M=[...Array(rows)].map(()=>Array(cols).fill(0));for(let i=0;i<A.length;i++)for(let j=0;j<cols;j++)M[i][j]=A[i][j];M[rows-1][cols-1]=1;const b=Array(rows).fill(0);b[rows-1]=1;const aug=M.map((row,i)=>row.concat([b[i]]));const gcd=(a,b)=>b?gcd(b,a%b):Math.abs(a);const lcm=(a,b)=>Math.abs(a*b)/gcd(a,b);for(let col=0,row=0;col<cols&&row<rows;col++){let piv=row;while(piv<rows&&aug[piv][col]===0)piv++;if(piv===rows)continue;[aug[row],aug[piv]]=[aug[piv],aug[row]];const pv=aug[row][col];for(let c=col;c<=cols;c++)aug[row][c]/=pv;for(let r=0;r<rows;r++){if(r===row)continue;const f=aug[r][col];if(f!==0)for(let c=col;c<=cols;c++)aug[r][c]-=f*aug[row][c]}row++}const x=aug.slice(0,cols).map(r=>r[cols]||0);const den=x.map(v=>{const s=v.toString();return s.includes('.')?10**s.split('.')[1].length:1});const LCM=den.reduce((p,c)=>lcm(p,c),1);let nums=x.map(v=>Math.round(v*LCM));const G=nums.reduce((p,c)=>gcd(p,c),nums[0]||1);nums=nums.map(v=>Math.abs(v/G));const l=nums.slice(0,lhs.length),rr=nums.slice(lhs.length);const left=lhs.map((p,i)=>`${l[i]===1?'':l[i]+' '}${p.formula}`).join(' + ');const right=rhs.map((p,i)=>`${rr[i]===1?'':rr[i]+' '}${p.formula}`).join(' + ');return {balanced:`${left} -> ${right}`, left:l, right:rr}}
    async function localSolveEquation(reactants){
      const s = reactants.includes('->') ? reactants : `${reactants} -> H2O`;
      const {balanced} = balanceEquation(s);
      return { balanced_equation: balanced,
               products: balanced.split('->')[1].trim().split('+').map(x=>x.trim()),
               reaction_type: "balanced",
               enthalpy_kJ_per_mol: null,
               notes: "Balanced locally (static mode). ŒîH not estimated." };
    }
    function shells(z){const s=[];let left=z;const cap=[2,8,8,18];for(let i=0;i<cap.length&&left>0;i++){const take=Math.min(cap[i],left);s.push(take);left-=take}return s}
    async function localDrawElement(symbol){
      const Z=window.PERIODIC.Z[symbol]; if(!Z) return {error:"Unknown element"};
      const sh=shells(Z); const v=window.PERIODIC.valence[symbol]??(sh[sh.length-1]||0);
      const bohr=`<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg"><circle cx="200" cy="150" r="10" fill="black"/>${
        sh.map((n,i)=>`<circle cx="200" cy="150" r="${40+30*i}" fill="none" stroke="black"/>`).join("")
      }<text x="200" y="290" text-anchor="middle" font-family="sans-serif" font-size="14">${symbol} ‚Äî shells ${sh.join(", ")}</text></svg>`;
      const lewis=`<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg"><text x="200" y="150" text-anchor="middle" font-family="sans-serif" font-size="64">${symbol}</text>${
        Array.from({length:v}).map((_,i)=>{const a=(i/v)*2*Math.PI,R=70,x=200+R*Math.cos(a),y=150+R*Math.sin(a);return `<circle cx="${x.toFixed(1)}" cy="${y.toFixed(1)}" r="6"/>`;}).join("")
      }<text x="200" y="290" text-anchor="middle" font-family="sans-serif" font-size="14">Valence electrons: ${v}</text></svg>`;
      return {valence_electrons:v, bohr, bohr_rutherford:bohr, lewis, notes:"Simple model (first 20 elements)."};
    }
    function guessVSEPR(formula){const known={CO2:{shape:"linear",domains:"2 (2 bonding)",angles:"180¬∞",hyb:"sp"},BF3:{shape:"trigonal planar",domains:"3",angles:"120¬∞",hyb:"sp2"},SO2:{shape:"bent",domains:"3 (2+1)",angles:"~119¬∞",hyb:"sp2"},CH4:{shape:"tetrahedral",domains:"4",angles:"109.5¬∞",hyb:"sp3"},NH3:{shape:"trigonal pyramidal",domains:"4 (3+1)",angles:"~107¬∞",hyb:"sp3"},H2O:{shape:"bent",domains:"4 (2+2)",angles:"~104.5¬∞",hyb:"sp3"},"C(graphite)":{system:"network",shape:"planar layers",domains:"3 per C",angles:"120¬∞",hyb:"sp2"},"C(diamond)":{system:"network",shape:"tetrahedral network",domains:"4 per C",angles:"109.5¬∞",hyb:"sp3"}};const k=formula.replace(/\s+/g,'');const d=known[k]||known[k.toUpperCase()]||known[k.replace(/[()]/g,'')];if(d)return {system:d.system||"molecule", name:k, formula:k, shape:d.shape, electron_domains:d.domains, bond_angles_deg:d.angles, hybridization:d.hyb, svg:null};const m=/^([A-Z][a-z]?)/.exec(k);const c=m?m[1]:"X";const counts={};(k.match(/[A-Z][a-z]?\d*/g)||[]).forEach(tok=>{const el=/^[A-Z][a-z]?/.exec(tok)[0];const n=parseInt(tok.slice(el.length)||"1",10);counts[el]=(counts[el]||0)+n});const bonds=(Object.entries(counts).reduce((a,[el,n])=>el===c?a:a+n,0));const V=(window.PERIODIC.valence[c]??4);const lone=Math.max(0,V-bonds);const domains=bonds+(lone>0?1:0)+(lone>2?1:0);const map={2:"linear",3:lone?"bent":"trigonal planar",4:lone>=2?"bent":lone===1?"trigonal pyramidal":"tetrahedral"};const ang={linear:"180¬∞","trigonal planar":"120¬∞",tetrahedral:"109.5¬∞","trigonal pyramidal":"~107¬∞",bent:"~104‚Äì119¬∞"};const hyb={linear:"sp","trigonal planar":"sp2",tetrahedral:"sp3","trigonal pyramidal":"sp3",bent:"sp2/sp3"};const shape=map[domains]||"unknown";return {system:"molecule", name:k, formula:k, shape, electron_domains:`${domains} (approx)`, bond_angles_deg:ang[shape]||"‚Äî", hybridization:hyb[shape]||"‚Äî", svg:null}}
    async function localSolveVSEPR(input){const d=guessVSEPR(input.replace(/granite/ig,'graphite'));const svg=`<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg"><circle cx="200" cy="150" r="28" stroke="black" fill="none"/><text x="200" y="156" text-anchor="middle" font-family="sans-serif" font-size="18">${d.formula}</text></svg>`;return {...d, svg}}
    window.LocalChem = { localSolveEquation, localDrawElement, localSolveVSEPR };
  })();
  </script>

  <!-- C) your main app code file (listeners/UI). Keep this and remove any extra inline scripts. -->
  <script src="./app.js" defer></script>
  <script>
window.PERIODIC = {
  Z: {H:1, He:2, Li:3, Be:4, B:5, C:6, N:7, O:8, F:9, Ne:10, Na:11, Mg:12, Al:13, Si:14, P:15, S:16, Cl:17, Ar:18, K:19, Ca:20},
  valence: {H:1, He:0, Li:1, Be:2, B:3, C:4, N:3, O:2, F:1, Ne:0, Na:1, Mg:2, Al:3, Si:4, P:3, S:2, Cl:1, Ar:0, K:1, Ca:2}
};
window.BOND_ENERGY = {"H-H":436,"O=O":498,"C-H":413,"C-C":348,"C=C":614,"C‚â°C":839,"C=O":799,"O-H":463,"N‚â°N":945,"N-H":391,"C-O":358};
</script>
  <script>
// --- equation balancer (small, robust) ---
function parseFormula(f){const s=[{}];const r=/([A-Z][a-z]?|\(|\)|\d+)/g;let m;while((m=r.exec(f))){const t=m[1];if(t==='('){s.push({});continue}if(t===')'){const top=s.pop();const mult=/^\d+/.exec(f.slice(r.lastIndex))?.[0];const k=mult?parseInt(mult,10):1;if(mult)r.lastIndex+=mult.length;for(const e in top)s[s.length-1][e]=(s[s.length-1][e]||0)+top[e]*k;continue}if(/^\d+$/.test(t))continue;const el=t;const mult=/^\d+/.exec(f.slice(r.lastIndex))?.[0];const k=mult?parseInt(mult,10):1;if(mult)r.lastIndex+=mult.length;s[s.length-1][el]=(s[s.length-1][el]||0)+k}return s[0]}
function parseSide(side){return side.split('+').map(x=>{const t=x.trim();const m=/^\s*(\d+)\s+(.+)$/.exec(t);return m?{coef:parseInt(m[1],10),formula:m[2].trim()}:{coef:1,formula:t}})}
function buildMatrix(lhs,rhs){const sp=[...lhs,...rhs],els=new Set();sp.forEach(p=>{p.comp=parseFormula(p.formula);Object.keys(p.comp).forEach(k=>els.add(k))});const e=[...els],C=sp.length,R=e.length,A=[...Array(R)].map(()=>Array(C).fill(0));e.forEach((el,i)=>{lhs.forEach((p,j)=>A[i][j]=p.comp[el]||0);rhs.forEach((p,j)=>A[i][j+lhs.length]=-(p.comp[el]||0))});return {A,sp}}
function balanceEquation(input){const [L,R]=input.split('->').map(s=>s.trim());if(!L||!R)throw new Error("Use 'reactants -> products'");const lhs=parseSide(L),rhs=parseSide(R);const {A,sp}=buildMatrix(lhs,rhs);const rows=A.length+1,cols=A[0].length,M=[...Array(rows)].map(()=>Array(cols).fill(0));for(let i=0;i<A.length;i++)for(let j=0;j<cols;j++)M[i][j]=A[i][j];M[rows-1][cols-1]=1;const b=Array(rows).fill(0);b[rows-1]=1;const aug=M.map((row,i)=>row.concat([b[i]]));const gcd=(a,b)=>b?gcd(b,a%b):Math.abs(a);const lcm=(a,b)=>Math.abs(a*b)/gcd(a,b);for(let col=0,row=0;col<cols&&row<rows;col++){let piv=row;while(piv<rows&&aug[piv][col]===0)piv++;if(piv===rows)continue;[aug[row],aug[piv]]=[aug[piv],aug[row]];let pv=aug[row][col];for(let c=col;c<=cols;c++)aug[row][c]/=pv;for(let r=0;r<rows;r++){if(r===row)continue;const f=aug[r][col];if(f!==0)for(let c=col;c<=cols;c++)aug[r][c]-=f*aug[row][c]}row++}const x=aug.slice(0,cols).map(r=>r[cols]||0);const den=x.map(v=>{const s=v.toString();return s.includes('.')?10**s.split('.')[1].length:1});const LCM=den.reduce((p,c)=>lcm(p,c),1);let nums=x.map(v=>Math.round(v*LCM));const G=nums.reduce((p,c)=>gcd(p,c),nums[0]||1);nums=nums.map(v=>Math.abs(v/G));const l=nums.slice(0,lhs.length),rr=nums.slice(lhs.length);const left=lhs.map((p,i)=>`${l[i]===1?'':l[i]+' '}${p.formula}`).join(' + ');const right=rhs.map((p,i)=>`${rr[i]===1?'':rr[i]+' '}${p.formula}`).join(' + ');return {balanced:`${left} -> ${right}`, left:l, right:rr}}
async function localSolveEquation(userInput){ // accepts "H2 + O2 -> H2O" or just "H2 + O2"
  const s=userInput.includes('->')?userInput:`${userInput} -> ?`; // UI may pass reactants only; you can pre-fill products later
  const {balanced}=balanceEquation(s.replace(/\?$/,'H2O')); // tiny convenience for demo
  return {
    balanced_equation: balanced,
    products: balanced.split('->')[1].trim().split('+').map(x=>x.trim()),
    reaction_type: "balanced",
    enthalpy_kJ_per_mol: null,
    notes: "Balanced locally; ŒîH not estimated in static mode."
  };
}

// --- VSEPR (rule-of-thumb) ---
function guessVSEPR(formula){
  const known={
    CO2:{shape:"linear",domains:"2 (2 bonding)",angles:"180¬∞",hyb:"sp"},
    BF3:{shape:"trigonal planar",domains:"3 (3 bonding)",angles:"120¬∞",hyb:"sp2"},
    SO2:{shape:"bent",domains:"3 (2 bonding, 1 lone)",angles:"~119¬∞",hyb:"sp2"},
    CH4:{shape:"tetrahedral",domains:"4 (4 bonding)",angles:"109.5¬∞",hyb:"sp3"},
    NH3:{shape:"trigonal pyramidal",domains:"4 (3 bonding, 1 lone)",angles:"~107¬∞",hyb:"sp3"},
    H2O:{shape:"bent",domains:"4 (2 bonding, 2 lone)",angles:"~104.5¬∞",hyb:"sp3"},
    PCl5:{shape:"trigonal bipyramidal",domains:"5",angles:"90¬∞/120¬∞",hyb:"sp3d"},
    SF6:{shape:"octahedral",domains:"6",angles:"90¬∞",hyb:"sp3d2"},
    "C(graphite)":{system:"network",shape:"planar layers",domains:"3 per C",angles:"120¬∞",hyb:"sp2"},
    "C(diamond)":{system:"network",shape:"tetrahedral network",domains:"4 per C",angles:"109.5¬∞",hyb:"sp3"},
  };
  const key=formula.replace(/\s+/g,'');
  const k = known[key] || known[key.toUpperCase()] || known[key.replace(/[()]/g,'')];
  if(k) return {system:k.system||"molecule", name:key, formula:key, ...k, svg:null};

  // very-lightweight fallback: central atom = first element; treat others as sigma bonds
  const m=/^([A-Z][a-z]?)/.exec(key); const central=m?m[1]:"X";
  const counts={}; (key.match(/[A-Z][a-z]?\d*/g)||[]).forEach(tok=>{const el=/^[A-Z][a-z]?/.exec(tok)[0];const n=parseInt(tok.slice(el.length)||"1",10);counts[el]=(counts[el]||0)+n;});
  const bonds=(Object.entries(counts).reduce((a,[el,n])=>el===central?a:a+n,0));
  const V=window.PERIODIC.valence[central]??4; const lone=Math.max(0, V - bonds);
  const domains=bonds + (lone>0?1:0) + (lone>2?1:0); // crude
  const map={2:"linear",3: lone? "bent":"trigonal planar",4: lone>=2?"bent":lone===1?"trigonal pyramidal":"tetrahedral"};
  const ang={linear:"180¬∞","trigonal planar":"120¬∞",tetrahedral:"109.5¬∞","trigonal pyramidal":"~107¬∞",bent:"~104‚Äì119¬∞"};
  const hybMap={linear:"sp","trigonal planar":"sp2",tetrahedral:"sp3","trigonal pyramidal":"sp3",bent:"sp2/sp3"};
  const shape=map[domains]||"unknown";
  return {system:"molecule", name:key, formula:key, shape, electron_domains:`${domains} (approx)`, bond_angles_deg:ang[shape]||"‚Äî", hybridization:hybMap[shape]||"‚Äî", svg:null};
}
async function localSolveVSEPR(input){
  const d=guessVSEPR(input.replace(/granite/ig,'graphite'));
  // simple dot SVG
  const svg=`<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg"><circle cx="200" cy="150" r="28" stroke="black" fill="none"/><text x="200" y="156" text-anchor="middle" font-family="sans-serif" font-size="18">${d.formula}</text></svg>`;
  return {...d, svg};
}

// --- Drawings: Bohr / Lewis (first 20 elements) ---
function shells(z){const s=[];let left=z;const cap=[2,8,8,18];for(let i=0;i<cap.length&&left>0;i++){const take=Math.min(cap[i],left);s.push(take);left-=take}return s}
async function localDrawElement(symbol){
  const Z=window.PERIODIC.Z[symbol]; if(!Z) return {error:"Unknown element"};
  const s=shells(Z); const v=window.PERIODIC.valence[symbol]??(s[s.length-1]||0);
  const bohr=`<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
  <circle cx="200" cy="150" r="10" fill="black"/>
  ${s.map((n,i)=>`<circle cx="200" cy="150" r="${40+30*i}" fill="none" stroke="black"/><!-- ${n} e- -->`).join("")}
  <text x="200" y="290" text-anchor="middle" font-family="sans-serif" font-size="14">${symbol} ‚Äî shells ${s.join(", ")}</text>
  </svg>`;
  const lewis=`<svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
  <text x="200" y="150" text-anchor="middle" font-family="sans-serif" font-size="64">${symbol}</text>
  ${Array.from({length:v}).map((_,i)=>{
    const ang=(i/v)*2*Math.PI, R=70, x=200+R*Math.cos(ang), y=150+R*Math.sin(ang);
    return `<circle cx="${x.toFixed(1)}" cy="${y.toFixed(1)}" r="6" />`;
  }).join("")}
  <text x="200" y="290" text-anchor="middle" font-family="sans-serif" font-size="14">Valence electrons: ${v}</text>
  </svg>`;
  return {valence_electrons:v, bohr, bohr_rutherford:bohr, lewis, notes:"Simple model (first 20 elements supported)."};
}

// expose
window.LocalChem = { localSolveEquation, localSolveVSEPR, localDrawElement };
</script>
</body>
</html>











